<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《计算机网络 自顶向下方法》笔记：第四章 网络层：数据平面 | ℡傲雪&amp;星火ぴ</title><meta name="author" content="℡傲雪&amp;星火ぴ"><meta name="copyright" content="℡傲雪&amp;星火ぴ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、导论 1.网络层概述 提供的服务：   在发送主机和接收主机对之间传送报文段（segment）   在发送端将报文段封装到数据报（datagram） 中   在接收端将数据报解封装，提取出报文段上交给传输层实体   网络层协议存在于每一个主机和路由器中   路由器会检查每一个经过它的 IP 数据报的头部   网络层的关键功能： 转发（forwarding）：指将分组从一个输入链路接口转移到适当">
<meta property="og:type" content="article">
<meta property="og:title" content="《计算机网络 自顶向下方法》笔记：第四章 网络层：数据平面">
<meta property="og:url" content="https://aoxuexinghuo.github.io/2024/10/13/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/index.html">
<meta property="og:site_name" content="℡傲雪&amp;星火ぴ">
<meta property="og:description" content="一、导论 1.网络层概述 提供的服务：   在发送主机和接收主机对之间传送报文段（segment）   在发送端将报文段封装到数据报（datagram） 中   在接收端将数据报解封装，提取出报文段上交给传输层实体   网络层协议存在于每一个主机和路由器中   路由器会检查每一个经过它的 IP 数据报的头部   网络层的关键功能： 转发（forwarding）：指将分组从一个输入链路接口转移到适当">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bu.dusays.com/2024/11/27/6746e05871049.jpg">
<meta property="article:published_time" content="2024-10-13T13:07:19.000Z">
<meta property="article:modified_time" content="2024-12-01T01:50:47.066Z">
<meta property="article:author" content="℡傲雪&amp;星火ぴ">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bu.dusays.com/2024/11/27/6746e05871049.jpg"><link rel="shortcut icon" href="/img/pikachu.png"><link rel="canonical" href="https://aoxuexinghuo.github.io/2024/10/13/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":"ture","top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":150,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《计算机网络 自顶向下方法》笔记：第四章 网络层：数据平面',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/progress_bar.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg" style="background-image: url(https://bu.dusays.com/2024/11/27/6746de97857ae.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/28/6747d82900e41.jpg" onerror="onerror=null;src='https://bu.dusays.com/2024/11/28/6748473533994.jpeg'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://bu.dusays.com/2024/11/27/6746e05871049.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">℡傲雪&amp;星火ぴ</span></a><a class="nav-page-title" href="/"><span class="site-name">℡傲雪&amp;星火ぴ</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><!--span= ' ' + _p('search.title')--></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">《计算机网络 自顶向下方法》笔记：第四章 网络层：数据平面</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-13T13:07:19.000Z" title="发表于 2024-10-13 21:07:19">2024-10-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-01T01:50:47.066Z" title="更新于 2024-12-01 09:50:47">2024-12-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">12k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="一、导论">一、导论</h2>
<h3 id="1-网络层概述">1.网络层概述</h3>
<p><strong>提供的服务</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在发送主机和接收主机对之间传送<strong>报文段（segment）</strong></p>
</li>
<li class="lvl-2">
<p>在发送端将报文段封装到<strong>数据报（datagram）</strong> 中</p>
</li>
<li class="lvl-2">
<p>在接收端将数据报解封装，提取出报文段上交给传输层实体</p>
</li>
<li class="lvl-2">
<p>网络层协议存在于每一个主机和路由器中</p>
</li>
<li class="lvl-2">
<p>路由器会检查每一个经过它的 IP 数据报的头部</p>
</li>
</ul>
<p><strong>网络层的关键功能</strong>：</p>
<p><strong>转发（forwarding）</strong>：指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作（即，对于每一个具体的数据交换结点，决定分组从某个端口入，再从某个合适的端口发送出去，是一个局部的概念）</p>
<p><strong>路由（routing）</strong>：指确定分组从源到目的地所采取的端到端路径的网络范围处理过程（即，规划从源到目标的详细路径，是一个全局的概念）</p>
<p>计算路由选择路径的算法被称为<strong>路由选择算法（routing algorithm）</strong>，在网络中交换路由信息的通信协议被称为<strong>路由选择协议（Routing Protocol）</strong>。</p>
<h3 id="2-数据平面">2.数据平面</h3>
<p><strong>功能</strong>：数据平面负责实际的数据报转发（即转发功能的实现）</p>
<p>每台网络路由器中都有一个关键元素——<strong>转发表（forwarding table）</strong></p>
<p><strong>转发功能的实现方式</strong>：传统方式、SDN（软件定义网络 Software Defined Network）方式</p>
<p><strong>传统方式</strong>：基于目标地址 + 转发表</p>
<p>路由器会检查到达分组首部的一个或多个字段值，进而使用这些首部值在其转发表中索引，通过这种方法来转发分组。</p>
<p><strong>SDN 方式</strong>：基于多个字段 + 流表（Flow Table）</p>
<p>SDN 中流是指共享首部某些字段的值的一种分组序列，如具有相同源IP地址和目的IP地址的一系列分组。SDN 中流表指分组交换机中用于转发的表（即记录流转发方式的表）。SDN使用流表取代传统路由器中的转发表。</p>
<p>在 SDN 方式下，数据平面设备包含一个或多个流表（Flow Table），用于存储流量匹配规则。数据平面采用基于多个字段匹配和流表的机制，可以实现更加灵活和精细的流量转发控制。通过 SDN 控制器对流表的集中化管理，网络管理员可以对整个网络进行可编程和自动化的配置和管理。</p>
<p>如果找到匹配项，交换机会根据流表中的指令执行相应的操作（如转发、丢弃、泛洪、修改数据包等）；如果没有找到匹配项，数据包会被转发到 SDN 控制器，由控制器决定如何处理并下发新的流表规则。</p>
<h3 id="3-控制平面">3.控制平面</h3>
<p><strong>功能</strong>：控制平面决定数据报如何在路由器之间路由，决定数据报从源到目标主机之间的端到端路径（即路由功能的实现）</p>
<p><strong>控制平面方法</strong>：传统方式、SDN方式</p>
<p><strong>传统的路由算法</strong>：</p>
<p>路由选择算法运行在每台路由器中，并且在<strong>每台路由器中都包含转发和路由选择两种功能</strong>。一台路由器中的路由选择算法与其他路由器中的路由选择算法通信，以计算出它的转发表的值。而这种通信的执行则依靠路由选择协议交换包含路由选择信息的路由选择报文。</p>
<p><strong>SDN 方法</strong>：</p>
<p>SDN 方式下控制平面路由选择功能与物理的路由器是分离的，即<strong>路由器选择设备仅执行转发</strong>，而远程控制器计算并分发流表。</p>
<p>SDN 允许网络管理员在不手动处理网络硬件设备的前提下，使用集中化程序重新规划网络，控制复杂网络拓扑以及网络流量。它打破了传统基础架构的限制，<strong>将传统的分布式规则计算演变为集中计算</strong>，具有低成本、管理简化、灵活性高和可扩展性强等优点。</p>
<blockquote>
<p><strong>注意</strong>：这里为了区分数据平面和控制平面，把传统方式和SDN方式各分割为两块来讲，因此可能有些混乱，难以理解。本章最后一节，我们将重新完整地讨论SDN方式。</p>
</blockquote>
<h3 id="4-网络服务模型">4.网络服务模型</h3>
<p><strong>网络服务模型（network service model）</strong> 定义了分组在发送与接收端系统之间的端到端运输特性。</p>
<p>这些服务包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>确保交付：该服务确保分组将最终到达目的地</p>
</li>
<li class="lvl-2">
<p>具有时延上界的确保交付：该服务不仅确保分组的交付，而且在特定的主机到主机时延上界内（例如在 100 ms 内）交付</p>
</li>
<li class="lvl-2">
<p>有序分组交付：该服务确保分组以他们发送的顺序到达目的地</p>
</li>
<li class="lvl-2">
<p>确保最小带宽：这种网络层服务模仿在发送和接收主机之间一条特定比特率（例如 1 Mbps）的传输链路的行为。只要发送主机以低于特定比特率的速率传输比特（作为分组的组成部分），则所有分组最终会交付到目标主机</p>
</li>
<li class="lvl-2">
<p>安全性：网络层能够在源加密所有数据报并在目的地解密这些分组，从而对所有运输层报文段提供机密性</p>
</li>
</ul>
<p>因特网的网络层提供了单一的服务，称为<strong>尽力而为服务（best-effort service）</strong>。使用尽力而为服务，传送的分组既不能保证以它们发送的顺序被接收，也不能保证它们最终交付；既不能保证端到端时延，也不能保证有最小的带宽（尽力而为服务是根本无服务的一种委婉的说法，因为即使一个没有向目的地交付分组的网络也依旧符合这种模型的定义）。</p>
<blockquote>
<p><strong>分组交换机</strong></p>
<p>在《自顶向下方法》中，我们约定分组交换机是指一台通用分组交换设备，他根据分组首部字段中的值，从输入链路接口到输出链路接口转移分组。某些分组交换机称为<strong>链路层交换机（link-layer switch）</strong>，基于链路层帧中的字段值做出转发决定，这些交换机因此被称为链路层设备；其他分组交换机称为<strong>路由器（router）</strong>，基于网络层数据报中的首部字段值做出转发决定，路由器因此是网络层设备。</p>
</blockquote>
<h2 id="二、路由器组成">二、路由器组成</h2>
<h3 id="1-路由器工作原理">1.路由器工作原理</h3>
<p>通用路由器的体系结构如下图所示：</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457b83e50eb.png" alt="1"></p>
<p>上方为控制平面，负责路由：运行路由选择算法/协议（RIP、OSPF、BGP） - 生成路由表</p>
<p>下方为数据平面，负责转发：从输入到输出链路交换数据报 - 根据路由表进行分组的转发</p>
<h3 id="2-输入端口处理和基于目的地转发">2.输入端口处理和基于目的地转发</h3>
<h4 id="（1）输入端口结构与功能">（1）输入端口结构与功能</h4>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457b8cd4ba6.png" alt="2"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>线路端接：处理Bit级的接收，通过物理层连接将外部信号接入路由器</p>
</li>
<li class="lvl-2">
<p>数据链路处理：在链路层根据协议标准进行数据拆包，将链路层帧转换为网络层数据包</p>
</li>
<li class="lvl-2">
<p>查找、转发、排队：数据包在进入路由器后，<strong>输入端口要进行查找操作</strong>（路由器使用转发表来查找输出端口，使得到达的分组能经过交换结构转发到该输出端口），然后决定是否将数据包转发到其他端口或队列进行排队，等待传输到输出端口。</p>
</li>
</ul>
<p>转发分为两种：<strong>基于目的地转发</strong>（仅仅依赖于 IP 数据报的目标 IP 地址，传统方法）和<strong>通用转发</strong>（基于头部字段的任意集合进行转发，更加灵活，能支持更复杂的策略和功能）</p>
<h4 id="（2）最长前缀匹配">（2）最长前缀匹配</h4>
<p>在基于目的地转发模式下，我们使用<strong>最长前缀匹配规则（longest prefix matching rule）</strong> 来查找路由。</p>
<p>假设我们的路由器有四条链路，路由器的转发表里只需要包括如下四个表项：</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457b97f4054.png" alt="3"></p>
<p>采用这种方式，路由表就不需要针对每个可能的目的地址都存储一个表项，大大减少了内存消耗。对于上面这种风格的转发表，路由器用分组目的地址的<strong>前缀（prefix）</strong> 与该表中的表项进行匹配。例如存在一个分组的目标地址是11001000 00010111 00010110 10100001，因为该地址的前 21 比特前缀匹配该表的第一项，所以路由器向链路接口 0 转发该分组。</p>
<p>如果有一个分组既能与第二项匹配，又能与第三项匹配，那么路由器会使用最长前缀匹配规则，选取第二项进行匹配，向与其对应的接口 1 发送分组。</p>
<h4 id="（3）输入端口缓存">（3）输入端口缓存</h4>
<p>当交换结构的速率小于输入端口的汇聚速率时，在输入端口可能需要排队，输入缓存溢出后可能造成丢失。</p>
<p>通常来说交换结构的速率被设计为足够快，以确保能够处理输入端口接收到的分组，那么为什么还是会产生排队呢？主要有以下几种原因：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>汇聚效应（流量突发）：多个输入端口可能同时接收到大量的流量，并且这些流量都需要通过同一个输出端口进行转发。</p>
</li>
<li class="lvl-2">
<p>队首阻塞问题（Head-of-Line Blocking）：比如，输入端口中的多个数据包等待被发送到不同的输出端口，但由于第一个数据包的目标输出端口暂时不可用，后续的数据包也无法被处理，导致整个输入队列阻塞，形成排队。</p>
</li>
<li class="lvl-2">
<p>非均匀流量分布：网络中的流量往往是非均匀分布的，有的端口可能处于空闲状态，而另一些端口可能会收到大量数据。如果多个输入端口的流量都要发送到某个输出端口时，交换结构虽然速率高，但在短时间内可能会出现流量竞争。</p>
</li>
</ul>
<h3 id="3-交换结构">3.交换结构</h3>
<h4 id="（1）交换结构的功能">（1）交换结构的功能</h4>
<p><strong>交换结构（Switching Fabric）</strong> 在路由器中起着核心作用，负责将数据包从输入缓冲区正确地转发到相应的输出端口。</p>
<p><strong>交换速率</strong>：分组可以按照该速率从输入端口传输到输出端口</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>运行速度通常是输入/输出链路速度的若干倍</p>
</li>
<li class="lvl-2">
<p>对于N个输入端口，交换结构的交换速率是输入线路速度的N倍才比较理想，不会成为瓶颈</p>
</li>
</ul>
<p>三种典型的交换结构见下图：分别是通过内存、总线、互联网络的交换</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457ba3aae1a.png" alt="4"></p>
<h4 id="（2）通过内存的交换">（2）通过内存的交换</h4>
<p>该交换结构下，输入端口与输出端口之间的交换是在CPU（路由选择处理器）的直接控制下完成的。</p>
<p>在这种情况下，如果内存带宽为每秒可写进内存或从内存读出最多B个分组，则总的转发吞吐量（分组从输入端口被传送带输出端口的总速率）必然小于B/2，因为每个数据包需要写入和读出这两次操作。</p>
<p>此外，也无法同时转发两个分组，即使它们有不同的目的端口，因为经过共享系统总线，一次仅能执行一个内存读/写。</p>
<blockquote>
<p><strong>注意</strong>：基于内存的交换结构通常也使用共享总线，这是因为在基于内存的交换结构中，输入端口和输出端口都需要通过同一条总线与内存进行交互。</p>
</blockquote>
<h4 id="（3）通过总线的交换">（3）通过总线的交换</h4>
<p>该交换结构下，数据报通过共享总线，从输入端口转发到输出端口。</p>
<p>总线竞争：交换速率受限于总线的带宽</p>
<p>如果多个分组同时到达路由器，每个位于不同的输出端口，除了一个分组外所有其他分组必须等待，因为一次只有一个分组能够跨越总线。因为每个分组必须跨过单一总线，故路由器的交换带宽受总线速率的限制；</p>
<h4 id="（4）通过互联网络的交换">（4）通过互联网络的交换</h4>
<p>该交换结构下，同时并发转发多个分组，克服单一、共享式总线带宽限制。</p>
<p>例如纵横式（crossbar）交换机就是一种用 2N 条总线组成的互联网络，它连接N个输入端口与N个输出端口。每条垂直的总线在交叉点与每条水平的总线交叉，交叉点通过交换结构控制器能够在任何时间开启和闭合。</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457bb42fd8c.png" alt="5"></p>
<p>纵横式网络能够并行转发多个分组。例如当分组达到端口A，需要转发到端口Y时，交换机控制器闭合总线A和Y交叉部位的的交叉点，然后端口A在其总线上发送该分组，该分组仅由总线Y接收。而来自端口B的一个分组在同一时间能够转发到端口X，因为A到Y和B到X的分组使用不同的输入和输出总线。</p>
<p>纵横式交换机是<strong>非阻塞的（nonblocking）</strong>，即只要没有其他分组当前被转发到该输出端口，转发到输出端口的分组将不会被到达输出端口的分组阻塞。然而，如果来自两个不同输入端口的两个分组其目的地为相同的输出端口，则一个分组必须在输入端等待，因为在某个时刻，经给定总线仅能够发送一个分组。</p>
<blockquote>
<p><strong>注</strong>：这里非阻塞的定义是中文版书上的原话，我只能说非常抽象。我们可以把它理解为只要目标输出端口是空闲的，输入端口的分组就可以立即传输到该输出端口，不会因为交换结构本身的原因被阻塞。</p>
</blockquote>
<p>更为复杂的互联网络使用多级交换元素，以使来自不同输入端口的分组通过交换结构同时朝着相同的输出端口前行。</p>
<h3 id="4-输出端口处理">4.输出端口处理</h3>
<h4 id="（1）输出端口结构与功能">（1）输出端口结构与功能</h4>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457bbd78ef5.png" alt="6"></p>
<p>与输入端口对应，输出端口处理取出已经存放在输出端口内存中的分组并将其发送到输出链路上。这包括选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能。</p>
<h4 id="（2）输出端口缓存">（2）输出端口缓存</h4>
<p>当来自不同输入端口的多个分组的目的地是相同的输出端口，因为交换结构的交换速率一般是输出线路速度的N倍（假定输入线路速度与输出线路速度相同），所以分组会很快地堆积在该输出端口，形成分组队列。</p>
<p>当没有足够的内存来缓存一个入分组是，就必须做出决定：丢弃到达的分组（采用一种称为<strong>弃尾（drop-tail）</strong> 的策略），要么删除一个或多个已排队的分组为新来的分组腾出空间。</p>
<p><strong>主动队列管理（Active Queue Management, AQM）</strong> 是一类用于缓解网络拥塞的算法，旨在在网络设备（如路由器）的缓冲区尚未填满之前采取措施，通过主动丢弃或标记分组，向发送方提供拥塞信号，以促使发送方调整其传输速率，从而防止拥塞进一步加剧。</p>
<p><strong>随机早期检测（Random Early Detection, RED）</strong> 算法是得到最广泛研究和实现的 AQM 算法之一</p>
<h3 id="5-调度机制">5.调度机制</h3>
<p>调度机制用于处理排队的分组如何经输出链路传输的问题。</p>
<blockquote>
<p><strong>注意</strong>：分组的丢弃不属于调度机制的范畴，分组调度的主要任务是决定哪个数据包应该首先被传输。</p>
</blockquote>
<h4 id="（1）先进先出">（1）先进先出</h4>
<p><strong>先进先出（First-In-First-Out, FIFO）</strong>，也称先来先服务（FCFS）调度规则，按照分组到达输出链路队列的先后顺序来选择分组在链路上传输。</p>
<p>FIFO规则的运行过程如下图所示：</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457bcb5c47d.png" alt="8"></p>
<h4 id="（2）优先权排队">（2）优先权排队</h4>
<p>在<strong>优先权排队（priority queuing）</strong> 规则下，到达输出链路的分组被分类放入输出队列中的优先权类，如下图所示。</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457bd2e50da.png" alt="9"></p>
<p>每个优先权类通常有自己的队列（不仅仅局限于图中的两种优先级），当选择一个分组传输时，优先权排队规则将从队列中为非空的的最高优先权类中传输一个分组。对于同一优先权类的分组之间的选择通常以FIFO方式完成。</p>
<p>在<strong>非抢占式优先权排队（non-preemptive priority queuing）</strong> 规则下，一旦分组开始传输，就不能打断。例如在下面的这个过程中，分组1、3和4属于高优先权类，分组2和5属于低优先权类。分组4到达时，分组2正在传输中，分组4不会将其打断，而是排队等待传输，等其传输完成后开始传输。</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457bdbebc9d.png" alt="10"></p>
<h4 id="（3）循环和加权公平排队">（3）循环和加权公平排队</h4>
<p>在<strong>循环排队规则（round robin queuing discipline）</strong> 下，分组被分成不同的类，但类之间不在优先级。循环调度器在这些类之间轮流提供服务，传输完类1的一个分组后，开始传输类2的一个分组，然后是类3，以此类推，最后循环到类1。一个所谓的<strong>保持工作排队（work-conserving queuing）</strong> 规则在有（任何类的）分组排队等待传输时，不允许链路保持空闲，也就是说当前类没有分组时，会立即检查循环序列中的下一个类。</p>
<p>在<strong>加权公平排队（Weighted Fair Queuing, WFQ ）</strong> 规则下，分组会被分到不同的类，WFQ调度器也以循环的方式为各个类提供服务（同时它也是一种保持工作排队规则，即当前类为空则立刻检查下一个类）。但是由于每个类在任何时间间隔内可能收到不同数量的分组，因此每个类都会被分配一个权w，每一个类在一个循环中获得不同权重的服务量，如下图所示：</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457be8c99b7.png" alt="11"></p>
<p>实际上，每个队列得到的服务时间并不是严格按照权重比例的，因为它不会打断一个分组的传输来开始传输另一个分组。</p>
<h2 id="三、IP：Internet-Protocol">三、IP：Internet Protocol</h2>
<h3 id="1-IPv4数据报格式">1.IPv4数据报格式</h3>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457bf132be6.png" alt="12"></p>
<p>IPv4分组的首部各字段解释如下：</p>
<p><strong>版本</strong>：占4比特，指IP协议版本号，IPv4分组中此处应为4。</p>
<p><strong>首部长度</strong>：占4比特，指分组首部总长度，以4字节为单位进行计算，首部固定部分总长度20字节，故此字段最小值为5。</p>
<p><strong>服务类型</strong>：占8比特，在之后的更新中更名为区分服务，定义了分组在网络中的传输优先级和处理方式。</p>
<p><strong>数据报长度</strong>：占16比特，指IP分组总长度（首部长度与数据部分长度之和），单位为字节。因字段位数有限，故理论上分组最大长度为2的16次方减一，即65535字节。</p>
<p><strong>标识、标志、片偏移</strong>：分别占16、3、13比特，与IP分片有关，我们在下一小节详细介绍。</p>
<p><strong>寿命</strong>：占8比特，寿命（Time-To-Live，TTL）字段用来确保数据报不会永远在网络中循环，当一台路由器处理数据报时，该字段的值减一，若TTL字段减为0，则该数据报必须丢弃。</p>
<p><strong>协议</strong>：占8比特，指IP分组所运载高层协议的类型。此高层并非指传输层及以上，而是指存在网络层协议且依赖于IP协议进行传输的高层协议，下表为常见的协议及对应的类型值。</p>
<table border="1" cellspacing="0" cellpadding="5">
  <tr>
    <th>协议</th>
    <th>ICMP</th>
    <th>IGMP</th>
    <th>TCP</th>
    <th>UDP</th>
    <th>OSPF</th>
  </tr>
  <tr>
    <td>IP分组协议字段值</td>
    <td>1</td>
    <td>2</td>
    <td>6</td>
    <td>17</td>
    <td>89</td>
  </tr>
</table>
<p><strong>首部检验和</strong>：占16比特，只检验分组首部，不包括数据部分，保障路由选择关系的正确性。检验方式与UDP相同。</p>
<p><strong>源地址</strong>：占32比特，源主机的IP地址。</p>
<p><strong>目的地址</strong>：占32比特，目的主机的IP地址。</p>
<p><strong>选项字段</strong>：此字段可选，长度为4的整倍数字节，最长40字节。为保证首部以4字节对齐，若选项长度不足，则需进行填充（通常为0）。</p>
<h3 id="2-数据报分片与重组">2.数据报分片与重组</h3>
<p>数据链路层的数据帧数据部分最大长度称为最大传送单元（MTU），不同协议和链路类型的MTU不同。过大的IP数据报需要被分片，即分割成若干个小的数据报。</p>
<p><strong>标识</strong>：16比特，源主机发送该分组时计数器的数值，并非序号，分组之间无序号关联。</p>
<p><strong>标志</strong>：3比特，从左到右依次是保留位、禁止分片（DF，Don't Fragment）、更多分片（MF，More Fragment）。</p>
<p><strong>片偏移</strong>：13比特，以8字节为单位进行计算，记录分片数据在原始数据中的起始位置。因为总长度字段比片偏移字段多3比特，在数值表示范围上前者是后者的8倍，故片偏移计数单位为8字节。</p>
<p><strong>分片过程</strong>：</p>
<ol>
<li class="lvl-3">
<p>检查原分组总长度是否超过下一跳网络的MTU值，超过则继续执行接下来的分片步骤。</p>
</li>
<li class="lvl-3">
<p>检查原分组首部标志位DF，若DF为1则表示禁止分片，路由器将丢弃该分组，若DF为0则继续执行以下步骤。</p>
</li>
<li class="lvl-3">
<p>计算分片数据长度，片偏移。由于片偏移量的计数单位是8字节，因此分片数据最大长度必定为8的整倍数，同时不能超过MTU的值。</p>
</li>
<li class="lvl-3">
<p>生成分片数据报，每一个分片都需要加上首部。首部各字段与原始数据报的基本相同，主要只修改了总长度，标志，片偏移，而标识保持不变。最后一分片数据报MF标志位为0，其余数据报MF标志位为1。</p>
</li>
</ol>
<p><strong>分片重组</strong>：</p>
<p>分片重组仅发生在目的主机（而不是下一跳路由器），目的主机依据首部标识重组原始数据报，并通过片偏移计算分片数据在原始数据中的正确位置。</p>
<blockquote>
<p><strong>注意</strong>：由于每个分片都需要加上首部，所以MTU过小将导致分组有效载荷占比减少，从而降低通信效率。因此分片时，每片都会取最大长度，最后余下的部分单独作为一个分片。</p>
</blockquote>
<h3 id="3-IPv4地址">3.IPv4地址</h3>
<h4 id="（1）IP地址">（1）IP地址</h4>
<p><strong>IP地址</strong>是对主机或者路由器与网络的接口的编址，共32位。</p>
<p>这些地址通常按照<strong>点分十进制记法（dotled decimal notation）</strong> 书写，即地址中的每个字节用它的十进制形式书写，各字节间以句点隔开。</p>
<p>路由器通常有两个及以上的接口；主机可能有一个或多个接口，比如多网卡配置或虚拟接口。</p>
<h4 id="（2）子网">（2）子网</h4>
<p>一个子网内的节点（主机或者路由器）的IP地址的高位部分相同，这些节点构成的网络的一部分叫做<strong>子网（subnet）</strong>，IP地址的高位表示子网部分，地位表示主机部分。</p>
<p>子网内的各主机之间通信无需路由器介入，一跳可达（可借助交换机，因为交换机是链路层设备，不计入IP跳数）。</p>
<p>下图为包括三个子网的网络：</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457c01dd432.png" alt="13"></p>
<p>划分子网时，将每一个接口从主机或路由器上分开，构成一个个网络的孤岛，每一个孤岛都可称之为子网。以下图为例，我们将其划分为6个子网，因为每个路由器之间的网络也是一个子网。</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457c14349c7.png" alt="14"></p>
<blockquote>
<p><strong>注意</strong>：子网说到底其实是对网络的划分，而不是对主机和路由器这些设备的划分，个人认为上图的蓝色部分如果不把主机包括进去反而更好理解。</p>
</blockquote>
<h4 id="（3）IP地址分类">（3）IP地址分类</h4>
<p>IPv4地址的分类指的是将整个IPv4地址空间划分为大小不等的5块，对应于A类、B类、C类、D类、E类IPv4地址，其中，A、B、C三类地址是单播地址，占据了绝大部分；D类地址是多播地址（Multicast address）；E类地址是保留地址，用于实验或在将来使用。</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457c22cd38b.png" alt="15"></p>
<p>地址分类的区分依靠前几个比特，若第一位为0，则该地址为A类，否则判断第二位；若第二位为0，则该地址为B类地址，否则判断第三位，依此类推。</p>
<p>IPv4分类编址则是在分类的基础上，将A、B、C三类地址都分成固定长度的网络号和主机号，三类地址的网络号长度分别为一、二、三字节（包含前面用于区分类别的比特）。由此我们可以得出，A类地址空间被划分为2的7次方个地址块，每个地址块包含2的24次方个IP地址（但是主机号全为0和全为1的为特殊地址，一般不作分配），其他类型地址同理。</p>
<p>部分IPv4地址具有特殊用途，我们称之为<strong>特殊地址</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>网络地址</strong>：主机号全0，是一个地址块的首地址，表示网络本身，不分配给主机。</p>
</li>
<li class="lvl-2">
<p><strong>本网某个特定的主机地址</strong>：网络号全0，表示本网络某台主机，如<code>0.0.103.123</code>。</p>
</li>
<li class="lvl-2">
<p><strong>直接广播地址</strong>：主机号全1，是一个地址块的末尾地址。广播是指将分组发送给网络中的所有主机。</p>
</li>
<li class="lvl-2">
<p><strong>全0地址</strong>：可以表示整个网络所有主机。</p>
</li>
<li class="lvl-2">
<p><strong>全1地址</strong>：称为受限广播地址，受限指路由器拦截广播分组扩散到其他网络，只能在局域网内广播。</p>
</li>
<li class="lvl-2">
<p><strong>回环地址</strong>：用于本地软件的测试的地址块，范围是<code>127.0.0.0</code>~<code>127.255.255.255</code>，以任一回环地址为目的的分组都不会离开本机，传输到网络层时会直接返回。</p>
</li>
<li class="lvl-2">
<p><strong>专用网址</strong>：局域网内部私有地址。私有地址可重复使用，不违背IP地址的全局唯一性。经过路由器NAT地址转换，私有地址将被隐藏在内部网络中，后面将详细讲NAT。</p>
</li>
</ul>
<h4 id="（4）CIDR与子网掩码">（4）CIDR与子网掩码</h4>
<p>CIDR，即<strong>无类域间路由（Classless InterDomain Routing）</strong> 中，不再将IP地址分为A类B类等，允许子网掩码在任意位置划分，格式为a.b.c.d/x，其中x是地址中子网号的长度。</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457c2d0f3a9.png" alt="16"></p>
<p>图中网络号为23位，主机号为9位，<strong>子网掩码（subnet mask）</strong> 的前23位为1，其余为0。因此我们将子网掩码与IP地址按位做与操作，就会得到该IP地址的网络号。</p>
<p>子网掩码的另一种表达方式就是 <strong>/#</strong>，例如图中的/23就表示前23个比特为子网部分。</p>
<p>而原始的A、B、C类网络的子网掩码分别是</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>A：<code>255.0.0.0</code> ： <code>11111111 00000000 00000000 00000000</code></p>
</li>
<li class="lvl-2">
<p>B：<code>255.255.0.0</code> ： <code>11111111 11111111 00000000 00000000</code></p>
</li>
<li class="lvl-2">
<p>C：<code>255.255.255.0</code> ： <code>11111111 11111111 11111111 00000000</code></p>
</li>
</ul>
<h4 id="（5）转发表和转发算法">（5）转发表和转发算法</h4>
<p>转发表中主要包括四项：目的子网号、子网掩码、下一跳、接口。</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457c391023e.png" alt="17"></p>
<p>表的最后一项是默认路由（Default），当没有找到明确的匹配项时，将会匹配这一项。</p>
<blockquote>
<p><strong>网络中数据报的转发</strong></p>
<p>当路由器转发数据报时，主机号部分在路由表查询时没有意义。路由器根据子网进行匹配和查找路由表，而不是基于具体的IP地址，因为以IP地址为单位进行路由信息通告和计算代价过大。只有只有当数据报到达最后一跳路由器时，该路由器已经在目标子网内，才需要使用主机号来定位并转发给目标主机。在之前的路由过程中，所有路由器只关心网络部分。正因为这种通过多个网络逐跳传递数据的方式，我们称互联网为“网络的网络”。</p>
</blockquote>
<h3 id="4-地址的获取">4.地址的获取</h3>
<h4 id="（1）获取一块地址">（1）获取一块地址</h4>
<p>在了解主机如何从组织的地址块中分配到自己的地址之前，我们先探讨一下组织的地址块是如何获取的。</p>
<p>第一种方法是网络管理员与自己的ISP（因特网服务提供商）提出申请，然后该ISP从自己的地址块中划分出一块提供给申请的组织。</p>
<p>看到这我们不免会想：ISP的地址块又是从哪来的呢？</p>
<p>第二种方法便是由<strong>因特网名字和编号分配机构（Internet Corporation for Assigned Names and Numbers，ICANN）[ICANN 2016]</strong> 进行管理分配。</p>
<p>ICANN是一个非营利的组织，具有管理IP地址空间并向各ISP和其他组织分配地址块的最终责任。除了分配地址外，它还负责管理DNS根服务器，分配域名和解决域名冲突。</p>
<h4 id="（2）层次编址和路由聚集">（2）层次编址和路由聚集</h4>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457c525d666.png" alt="20"></p>
<p>以上图为例，ISP将8个组织连接到因特网，其只需要对外界通告：向它发送以<code>200.23.16.0/20</code>开始的任何东西即可。外界的其他部分不需要知道地址块<code>200.23.16.0/20</code>在内部还被划分成了其他八个子网。这种使用单个网络前缀通告多个网络的能力通常称为<strong>路由聚合（route aggregation）</strong>。</p>
<p>这个例子也说明了仔细分配CIDR化的地址有利于路由选择的道理。但如果地址不是按这样的层次方式分配时，会出现什么情况呢？</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457c66863cc.png" alt="21"></p>
<p>在这张图中，组织1的地址块被分配到了另一个ISP。原ISP对外界的通告保持不变，另一个ISP只需要向外通告对其发送以<code>200.23.16.0/20</code>开始的东西即可，这是一个到组织1更加具体的路由。外界向组织1发送内容时，会根据最长前缀匹配原则，选择第二个ISP。</p>
<h4 id="（3）获取主机地址：动态主机配置协议">（3）获取主机地址：动态主机配置协议</h4>
<p>主机想要从组织里获取一个IP地址也有两种方式。第一种方式是静态 IP 地址分配，即由网络管理员手动修改配置文件，为每个主机配置一个唯一的 IP 地址。这种方式虽然稳定且便于精细化管理，但却有着很高的维护成本。</p>
<p>目前采用的更多是第二种方法，即<strong>动态主机配置协议（Dynamic Host Configuration，DHCP）</strong>。<strong>DHCP是基于UDP的应用层协议，负责IP地址的集中管理和自由分配</strong>。</p>
<p>DHCP允许主机自动获取一个 IP 地址。网络管理员能够配置 DHCP，使某给定主机每次与网络连接时能得到一个相同的IP地址，或者某主机将被分配一个临时的IP地址（temporary IP address），每次与网络连接时该地址也许是不同的。由于DHCP这种即插即用的自动分配 IP 地址的能力，故又被成为<strong>即插即用协议（plug-and-play protocol）</strong> 或零配置（zeroconf）协议。</p>
<p>除了主机IP地址分配外，DHCP还会发送一些其他的信息，如子网掩码，默认网关（第一跳路由器的IP地址），本地DNS服务器的地址等。</p>
<p>我们以下图为例详细介绍DHCP的工作流程：</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457c7701b32.png" alt="18"></p>
<p>DHCP是一个客户-服务器协议，客户是新到达的主机，请求包括自身使用的IP地址在内的网络配置信息。图中有一台连接到子网<code>223.1.2/24</code>的DHCP服务器，虽然剩下的两个子网虽然没有自己的DHCP服务器，但可以由图中的路由器作为DHCP中继代理，为另外两个子网上的客户提供DHCP服务。</p>
<p>对于一个新到达的主机，DHCP协议的工作流程可以分为以下四步：</p>
<p><strong>DHCP服务器发现</strong>：新接入网络的主机会尝试获取 IP 地址，它会向网络发送一个<strong>DHCP发现报文（DHCP discover message）</strong>。该报文是广播报文，目的是寻找网络中可用的 DHCP 服务器。由于主机在初始阶段还没有 IP 地址，所以报文是从源 IP <code>0.0.0.0</code> 广播到目的 IP <code>255.255.255.255</code>。这个过程使 DHCP 服务器得知有新设备需要分配 IP 地址。</p>
<p><strong>DHCP服务器提供</strong>：DHCP服务器收到一个DHCP发现报文时，会从其可用的 IP 地址池中选取一个地址，并用**DHCP提供报文（DHCP offer message）**向客户做出回应，告知主机它可以使用这个 IP 地址，该报文依旧使用IP广播地址<code>255.255.255.255</code>。除了提供的IP地址外，该报文中还包括收到的发现报文的事务ID、网络掩码以及IP地址租用期（address lease time），即IP地址的有效时间量。</p>
<p><strong>DHCP请求</strong>：新到达的客户从一个或多个服务器提供中选择一个，并向其发送<strong>DHCP请求报文（DHCP request message）</strong>，来告知 DHCP 服务器它选择了哪个提供的 IP 地址。这个请求报文也可以用来更新、续订或释放之前分配的 IP 地址。</p>
<p><strong>DHCP ACK</strong>：当 DHCP 服务器收到主机的请求报文后，会发送一个**DHCP确认报文（DHCP Acknowledgment Message）**给主机，告知其正式使用提供的 IP 地址及配置信息。</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457c8474549.png" alt="19"></p>
<p>一旦客户收到DHCP ACK后，交互便完成了，该客户可以在租用期内使用DHCP分配的IP地址。</p>
<p>对于不是新到达的主机，即已经获得过IP地址并且租约尚未到期的主机，可以跳过DHCP流程中的前两步，直接发送DHCP请求报文给之前的DHCP服务器。只有在原来的DHCP服务器不可用或租约失效时，才会重新执行完整的DHCP四步流程。</p>
<blockquote>
<p><strong>DHCP提供报文也使用广播地址的原因</strong></p>
<ol>
<li class="lvl-3">新主机没有获得正式的IP地址，无法对其进行定向的单播通信。</li>
<li class="lvl-3">网络中可能有多个DHCP服务器在监听，它们可能会同时响应，并提供可用的IP地址。广播发送可以确保所有处于同一子网的客户端都能接收到DHCP服务器的提供信息，并且由客户端从中选择一个合适的服务器。</li>
</ol>
</blockquote>
<h3 id="5-NAT：网络地址转换">5.NAT：网络地址转换</h3>
<h4 id="（1）NAT介绍">（1）NAT介绍</h4>
<p><strong>网络地址转换（NAT，Network Address Translation）</strong> 是一种将一个网络的私有IP地址映射到另一个网络的公共IP地址，以实现内网主机与外部网络（如互联网）之间的通信的网络技术。</p>
<p>借助NAT技术，我们可以实现一块局域网内部的设备公共一个IP地址，而不需要从ISP分配一块地址。</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457c9170bdc.png" alt="22"></p>
<p>上图是一个NAT模型，右方设备的内网IP地址在外网中是没有意义的，所有离开本地网络的数据报经过默认网关（即图中的路由器），源地址都会由私有IP地址转换为公共IP地址<code>138.76.29.7</code>（但是端口号不同，用于区分内网的不同设备），这个地址是一个在外网中有效的地址。</p>
<p>NAT技术的作用包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>降低成本，内网的所有设备在外部共用一个IP地址。</p>
</li>
<li class="lvl-2">
<p>增强网络的安全性，内网的设备没有明确的地址，对外不可见。</p>
</li>
<li class="lvl-2">
<p>提高IP地址的利用率，解决IPv4地址不足的问题。</p>
</li>
</ul>
<h4 id="（2）NAT转换表">（2）NAT转换表</h4>
<p>从广域网到达NAT路由器的所有数据报也都具有相同的目的IP地址，为了区分该数据报应该被转发到哪个内部主机，我们在NAT路由器上引入了一张<strong>NAT转换表（NAT translation table）</strong>，表项中包含了端口号以及IP地址。</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457c9d8f32d.png" alt="23"></p>
<p>我们以上图为例讲解NAT转换表的工作原理：</p>
<p>主机<code>10.0.0.1</code>向<code>128.119.40.186</code>，80号端口发送数据报，该数据报的源地址为<code>10.0.0.1</code>，3345号端口，目标地址为<code>128.119.40.186</code>，80号端口。该数据报到达NAT路由器后，路由器将其源地址修改为此内网公用的IP地址，并选一个没有被占用的端口号来代表该内网主机，此时数据报的源地址为<code>138.76.29.7</code>，5001号端口。然后将这种映射关系记录在NAT转换表中。当NAT路由器收到广域网返回的响应数据报时，该数据报的目标地址为<code>138.76.29.7</code>，5001号端口。NAT路由器查找表项后发现，5001号端口对应的是内网的<code>10.0.0.1</code>，3345号端口。于是将数据报中的目标地址修改为<code>10.0.0.1</code>，3345号端口后，发送给对应内网主机。</p>
<h4 id="（3）NAT穿透">（3）NAT穿透</h4>
<p>在我上面的讨论中，都是由内网中的主机主动向外界联系。但由于内网的设备对外是不可见的，广域网的设备该如何主动联系到内网的设备呢？我们将这种情况称为NAT穿透（NAT traversal）问题。</p>
<p><strong>解决方案1：静态配置NAT</strong></p>
<p>预先在NAT路由器上配置好固定的映射规则，例如目标地址为<code>138.76.29.7</code>，5001号端口的数据报总是被转发到<code>10.0.0.1</code>，3345号端口。</p>
<p><strong>解决方案2：UPnP协议</strong></p>
<p><strong>通用即插即用（Universal Plug and Play，UPnP）协议</strong>允许内网主机通过自动发现和交互来主动与网关设备进行通信，然后通过<strong>IGD协议（Internet Gateway Device Protocol）</strong> 增加、删除或修改相应的表项从而实现动态调整（IGD是UPnP架构的一部分）。</p>
<p><strong>解决方案3：中继技术</strong></p>
<p>中继技术中，内网的主机如果想要被外网联系，可以先与中继服务器建立连接。当外网的设备也与中继服务器建立连接后，中继服务器就可以作为桥梁实现外网设备向内网设备的主动连接。</p>
<h3 id="6-IPv6">6.IPv6</h3>
<h4 id="（1）IPv6的动机">（1）IPv6的动机</h4>
<p>一个新事物的诞生自然伴随着对旧事物的批判，IPv6的初始动机便是IPv4的32字节地址空间会很快被用完。此外，IPv4的数据报头部在转发过程中是会变化的（例如TTL字段等），每次都需要重新计算校验和；IPv4的分片功能也会加剧路由器的负担，尤其是互联网骨干的核心路由器。</p>
<p>在这些弊端的基础上，IPv6采用了<strong>128位</strong>的超长地址，同时设置了固定的40字节头部。此外IPv6的数据报在传输过程中不允许分片，路由器会直接将过大的分组抛弃，然后通过<strong>ICMPv6协议</strong>向源主机发送一个消息，告知其需要发送更小的分组。这大大降低了路由器的负担。</p>
<h4 id="（2）IPv6数据报格式">（2）IPv6数据报格式</h4>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457caae8e73.png" alt="24"></p>
<p>IPv6的数据报格式如上图所示，具有固定的<strong>40字节</strong>头部，其中各字段的功能如下：</p>
<p><strong>版本</strong>：占4比特，用于表示IP版本号，这里毫不意外地将值设置为6。</p>
<p><strong>流量类型</strong>：占8比特，相当于IPv4的服务类型字段，用于区分优先级。</p>
<p><strong>流标签</strong>：占20比特。流（flow）的概念一直没有被严格地定义。我们可以理解为同一个IP发出来的属于同一个会话的数据，可以为其打上同样的一个流标签，试图让网络对同一个流的数据做出同样的处理。</p>
<p><strong>有效载荷长度</strong>：占16比特，该值作为一个无符号整数，给出了IPv6数据报中在定长的40字节数据报首部后面的字节数量。</p>
<p><strong>下一个首部</strong>：占8比特，标识数据报中的内容需要交付给哪个协议（如TCP或UDP），使用与IPv4首部中协议字段相同的值。</p>
<p><strong>跳限制</strong>：占8比特，转发数据报的每台路由器将对该字段的内容减1，如果跳限制计数达到了0，则该数据报将被丢弃。</p>
<h4 id="（3）和IPv4相比的变化">（3）和IPv4相比的变化</h4>
<p>IPv6相较于IPv4主要有以下几点变化和改进：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>校验和（checksum）被移除。因为链路层和传输层（如TCP和UDP）已经包含了校验和功能，IPv6不再重复验证，提高了数据报的处理速度。</p>
</li>
<li class="lvl-2">
<p>选择（Options）部分被移动到了头部之外。IPv6将所有可选字段放在了扩展头部中，并用下一个首部字段来指示是否存在扩展头部以及扩展头部的类型。</p>
</li>
<li class="lvl-2">
<p>ICMPv4升级为ICMPv6，ICMPv6是IPv6中的控制报文协议，与IPv4中的ICMP类似，用于网络诊断和错误报告。但支持更多功能，如新增报文类型“Packet Too Big”，如果数据包超过了链路的MTU，路由器不会进行分片，而是丢弃数据包，并向源主机发送一个“Packet Too Big”报文，以通知其需要分片成更小的数据包。</p>
</li>
<li class="lvl-2">
<p>除了单播和多播外，IPv6还引入了一种称为<strong>任播地址（anycast address）</strong> 的新型地址，这种地址可以使数据报交付给一组主机中的任意一个（例如，如果有多个镜像服务器都包含相同的数据，用户发出请求时，可以通过任播地址将请求数据报交付给距离最近的镜像服务器，从而实现更高效的数据获取和减少网络延迟）。</p>
</li>
</ul>
<h4 id="（4）IPv4到IPv6的迁移">（4）IPv4到IPv6的迁移</h4>
<p>由于如今互联网的规模十分庞大，IPv4到IPv6的迁移只能循序渐进。这将不可避免的产生IPv4和IPv6路由器的混合，此时互联网的运转主要依靠于<strong>隧道（tunnel）</strong>。</p>
<p>这里隧道的概念与我们传统意义上的隧道有一些区别，我们假定两个IPv6节点要使用IPv6数据报进行交互，但它们是经由中间IPv4路由器互联的，我们将两台IPv6路由器之间的IPv4路由器的集合称为一个隧道。借助于隧道，在隧道发送端的IPv6节点可将整个IPv6数据报放到一个IPv4数据报的数据字段中，运输过程中，中间的IPv4路由器将其当做正常的IPv4数据报进行运输。隧道接收端的IPv6节点最后收到该IPv4数据报，并确定其包含一个完整的IPv6数据报（通过观察IPv4数据报中的协议号字段是41）后，从中取出IPv6数据报，继续为其进行路由。</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457cb8c08b4.png" alt="25"></p>
<p>上图为IPv4数据报包裹IPv6数据报的结构图，类似于我们用船去运送汽车。</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457cc4aefea.png" alt="26"></p>
<p>上图为隧道的逻辑视图与物理视图，隧道为IPv6的逐步普及提供了平滑的过渡方案。以后随着IPv6网络逐渐增多，依赖于隧道技术的场景会逐渐减少，IPv4反而称为一个个孤岛，看过《三体》同学可能会感觉这里很像四维空间向三维的跌落过程。</p>
<h2 id="四、通用转发和SDN">四、通用转发和SDN</h2>
<h3 id="1-传统方式与SDN方式的比较">1.传统方式与SDN方式的比较</h3>
<p>在前面的内容中，我们所讲的都是传统方式，第二层交换机和第三层路由器等中间盒的剧增，而且每种都有自己特殊的硬件、软件和管理界面给许多网络操作管理带来了很大麻烦。而最新的<strong>软件定义网络（Software Defined Network，SDN）</strong> 通过将网络控制与数据转发分离，重新定义了网络的架构，为网络管理带来了灵活性和易用性。</p>
<p>前面提到，在传统方式中，路由器兼具路由和转发的功能。而在SDN方式中，控制平面被从每个网络设备中抽离出来，集中到一个或多个远程的SDN控制器上，路由器仅负责转发功能。</p>
<h3 id="2-通用转发">2.通用转发</h3>
<p>传统的基于目的地转发可以总结为以下两步，即查找IP地址（“匹配”），然后将分组发送到有特定输出端口的交换结构（“动作”）。我们将这两个概念抽离出来，考虑一种更加标准通用的“匹配加动作”范式。</p>
<p>SDN网络中的“匹配”不仅限于传统网络中的目的地IP地址，它可以对协议栈中多层首部字段进行匹配，这些首部字段是与不同层次的不同协议相关联的。通过支持对多个首部字段进行匹配，SDN可以提供更精细化的流量控制，可以根据不同的条件来匹配特定的数据包流。</p>
<p>SDN网络中的“动作”包括将分组转发到一个或多个输出端口（就像在基于目的地转发中一样），跨越多个通向服务的离开接口进行负载均衡分组（就像在负载均衡中一样），重写首部值（就像在NAT中一样），有意识地阻挡/丢弃某个分组（就像在防火墙中一样）等等。</p>
<p><img src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/26/67457cd0dd4cd.png" alt="27"></p>
<p>我们对通用转发的讨论都将OpenFlow（一个得到高度认可的成功标准）。“匹配加动作”转发表在OpenFlow中称为<strong>流表（flow table）</strong>，它的每个表项包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>首部字段值的集合，匹配不上流表项的分组将被丢弃或发送到远程控制器做更多处理。</p>
</li>
<li class="lvl-2">
<p>计数器集合，当分组与流表项匹配时更新计数器。这些计数器可以包括已经与该表项匹配的分组数量，以及自从该表项上次更新以来的时间。</p>
</li>
<li class="lvl-2">
<p>当分组匹配流表表项时所采取的动作集合，这些动作可能将分组转发到给定的输出端口，丢弃该分组、复制该分组和将它们发送到多个输岀端口，或重写所选的首部字段等（功能要远多于传统方式）。</p>
</li>
</ul>
<p>至于转发表（基于目标的转发）和流表（通用转发）是如何计算出来的，我们将在下一章控制平面继续讨论。</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>《计算机网络 自顶向下方法》笔记：第四章 网络层：数据平面</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://aoxuexinghuo.github.io/2024/10/13/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/">https://aoxuexinghuo.github.io/2024/10/13/《计算机网络 自顶向下方法》笔记：第四章 网络层：数据平面/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>℡傲雪&amp;星火ぴ</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-10-13</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-12-01</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post-share"><div class="social-share" data-image="https://bu.dusays.com/2024/11/27/6746e05871049.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/09/26/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/" title="《计算机网络 自顶向下方法》笔记：第三章 传输层"><img class="cover" src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/27/6746e02939613.jpg" onerror="onerror=null;src='https://bu.dusays.com/2024/11/28/674845666d85e.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">《计算机网络 自顶向下方法》笔记：第三章 传输层</div></div><div class="info-2"><div class="info-item-1">一、概述和传输层服务 1.传输层提供的服务 传输层为运行在不同主机上的应用进程提供逻辑通信。 传输层的协议运行在端系统（而不是路由器）：   发送方将应用层的报文分成报文段，然后穿递给下一层的网络层。   接收方从网络层接收后将报文段重组成报文，然后传递给上一层的应用层。    注意：本地进程间通信无需通过网络层和传输层，它们可以使用操作系统内核提供的进程间通信（IPC）机制进行直接通信。  2.传输层和网络层的比较 网络层服务：主机之间的逻辑通信 传输层服务：进程之间的逻辑通信 传输层运行在网络层的上层，将服务细分为主机间的进程通信 传输层在网络层的服务基础上对其进行加强。例如，解决网络层的数据丢失、顺序混乱等问题，但并不是所有的服务都能得到加强，比如带宽、延迟。 3.传输层协议 可靠的、保序的传输：TCP   多路复用、解复用   拥塞控制   流量控制   建立连接   不可靠的、不保序的传输：UDP   多路复用、解复用   没有为尽力而为的（best-effort）...</div></div></div></a><a class="pagination-related" href="/2024/10/24/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/" title="《计算机网络 自顶向下方法》笔记：第五章 网络层：控制平面"><img class="cover" src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/27/6746e05871049.jpg" onerror="onerror=null;src='https://bu.dusays.com/2024/11/28/674845666d85e.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">《计算机网络 自顶向下方法》笔记：第五章 网络层：控制平面</div></div><div class="info-2"><div class="info-item-1">一、概述 1.传统方式与SDN方式 在上一章的学习里我们了解到转发表（基于目的的转发）和流表（通用转发）是链接网络层的数据平面和控制平面的首要元素。这些表定义了一台路由器的本地数据平面转发行为，而在通用转发下，所采取的动作还包括丢弃一个分组、复制一个分组和重写第2、3或4层分组首部字段。 在本章中，我们将关注这些转发表和流表是如何计算、维护和安装的。实际上我们已经了解到在传统方式下和 SDN 方式下完成这些工作的两种方法，前者是由每个路由器完成，后者则是远程集中控制路由，路由器仅执行转发功能（当然还包括流表支持的一些其他动作，这些其他的动作以前都是由单独的中间盒实现的）。 我们可以根据下面两张图来回忆一下两种方式的区别：   2.传统方式的路由机制 而传统方式（区别于SDN）的路由机制又分为两个级别：内部网关协议（IGP，Interior Gateway Protocol） 和外部网关协议（EGP, Exterior Gateway...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/09/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/" title="《计算机网络 自顶向下方法》笔记：第一章 计算机网络和因特网"><img class="cover" src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/27/6746dee5408d3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-22</div><div class="info-item-2">《计算机网络 自顶向下方法》笔记：第一章 计算机网络和因特网</div></div><div class="info-2"><div class="info-item-1">有种高中生物的美。</div></div></div></a><a class="pagination-related" href="/2024/09/26/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/" title="《计算机网络 自顶向下方法》笔记：第三章 传输层"><img class="cover" src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/27/6746e02939613.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-26</div><div class="info-item-2">《计算机网络 自顶向下方法》笔记：第三章 传输层</div></div><div class="info-2"><div class="info-item-1">一、概述和传输层服务 1.传输层提供的服务 传输层为运行在不同主机上的应用进程提供逻辑通信。 传输层的协议运行在端系统（而不是路由器）：   发送方将应用层的报文分成报文段，然后穿递给下一层的网络层。   接收方从网络层接收后将报文段重组成报文，然后传递给上一层的应用层。    注意：本地进程间通信无需通过网络层和传输层，它们可以使用操作系统内核提供的进程间通信（IPC）机制进行直接通信。  2.传输层和网络层的比较 网络层服务：主机之间的逻辑通信 传输层服务：进程之间的逻辑通信 传输层运行在网络层的上层，将服务细分为主机间的进程通信 传输层在网络层的服务基础上对其进行加强。例如，解决网络层的数据丢失、顺序混乱等问题，但并不是所有的服务都能得到加强，比如带宽、延迟。 3.传输层协议 可靠的、保序的传输：TCP   多路复用、解复用   拥塞控制   流量控制   建立连接   不可靠的、不保序的传输：UDP   多路复用、解复用   没有为尽力而为的（best-effort）...</div></div></div></a><a class="pagination-related" href="/2024/09/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%BA%94%E7%94%A8%E5%B1%82/" title="《计算机网络 自顶向下方法》笔记：第二章 应用层"><img class="cover" src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/27/6746e02b1d09c.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-22</div><div class="info-item-2">《计算机网络 自顶向下方法》笔记：第二章 应用层</div></div><div class="info-2"><div class="info-item-1">一、应用层协议原理 1.网络应用程序体系结构 （1）客户-服务器体系结构（client-server...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AF%BC%E8%AE%BA"><span class="toc-text">一、导论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0"><span class="toc-text">1.网络层概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2"><span class="toc-text">2.数据平面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2"><span class="toc-text">3.控制平面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-text">4.网络服务模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%84%E6%88%90"><span class="toc-text">二、路由器组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">1.路由器工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BE%93%E5%85%A5%E7%AB%AF%E5%8F%A3%E5%A4%84%E7%90%86%E5%92%8C%E5%9F%BA%E4%BA%8E%E7%9B%AE%E7%9A%84%E5%9C%B0%E8%BD%AC%E5%8F%91"><span class="toc-text">2.输入端口处理和基于目的地转发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BE%93%E5%85%A5%E7%AB%AF%E5%8F%A3%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8A%9F%E8%83%BD"><span class="toc-text">（1）输入端口结构与功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D"><span class="toc-text">（2）最长前缀匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%BE%93%E5%85%A5%E7%AB%AF%E5%8F%A3%E7%BC%93%E5%AD%98"><span class="toc-text">（3）输入端口缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84"><span class="toc-text">3.交换结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">（1）交换结构的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%80%9A%E8%BF%87%E5%86%85%E5%AD%98%E7%9A%84%E4%BA%A4%E6%8D%A2"><span class="toc-text">（2）通过内存的交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%80%9A%E8%BF%87%E6%80%BB%E7%BA%BF%E7%9A%84%E4%BA%A4%E6%8D%A2"><span class="toc-text">（3）通过总线的交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E9%80%9A%E8%BF%87%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BA%A4%E6%8D%A2"><span class="toc-text">（4）通过互联网络的交换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BE%93%E5%87%BA%E7%AB%AF%E5%8F%A3%E5%A4%84%E7%90%86"><span class="toc-text">4.输出端口处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BE%93%E5%87%BA%E7%AB%AF%E5%8F%A3%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8A%9F%E8%83%BD"><span class="toc-text">（1）输出端口结构与功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%BE%93%E5%87%BA%E7%AB%AF%E5%8F%A3%E7%BC%93%E5%AD%98"><span class="toc-text">（2）输出端口缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6"><span class="toc-text">5.调度机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA"><span class="toc-text">（1）先进先出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BC%98%E5%85%88%E6%9D%83%E6%8E%92%E9%98%9F"><span class="toc-text">（2）优先权排队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%8A%A0%E6%9D%83%E5%85%AC%E5%B9%B3%E6%8E%92%E9%98%9F"><span class="toc-text">（3）循环和加权公平排队</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81IP%EF%BC%9AInternet-Protocol"><span class="toc-text">三、IP：Internet Protocol</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="toc-text">1.IPv4数据报格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87%E4%B8%8E%E9%87%8D%E7%BB%84"><span class="toc-text">2.数据报分片与重组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-IPv4%E5%9C%B0%E5%9D%80"><span class="toc-text">3.IPv4地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89IP%E5%9C%B0%E5%9D%80"><span class="toc-text">（1）IP地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%AD%90%E7%BD%91"><span class="toc-text">（2）子网</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB"><span class="toc-text">（3）IP地址分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89CIDR%E4%B8%8E%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81"><span class="toc-text">（4）CIDR与子网掩码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E8%BD%AC%E5%8F%91%E8%A1%A8%E5%92%8C%E8%BD%AC%E5%8F%91%E7%AE%97%E6%B3%95"><span class="toc-text">（5）转发表和转发算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9C%B0%E5%9D%80%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-text">4.地址的获取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%8E%B7%E5%8F%96%E4%B8%80%E5%9D%97%E5%9C%B0%E5%9D%80"><span class="toc-text">（1）获取一块地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%B1%82%E6%AC%A1%E7%BC%96%E5%9D%80%E5%92%8C%E8%B7%AF%E7%94%B1%E8%81%9A%E9%9B%86"><span class="toc-text">（2）层次编址和路由聚集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%8E%B7%E5%8F%96%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80%EF%BC%9A%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE"><span class="toc-text">（3）获取主机地址：动态主机配置协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-NAT%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-text">5.NAT：网络地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89NAT%E4%BB%8B%E7%BB%8D"><span class="toc-text">（1）NAT介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89NAT%E8%BD%AC%E6%8D%A2%E8%A1%A8"><span class="toc-text">（2）NAT转换表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89NAT%E7%A9%BF%E9%80%8F"><span class="toc-text">（3）NAT穿透</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-IPv6"><span class="toc-text">6.IPv6</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89IPv6%E7%9A%84%E5%8A%A8%E6%9C%BA"><span class="toc-text">（1）IPv6的动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89IPv6%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="toc-text">（2）IPv6数据报格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%92%8CIPv4%E7%9B%B8%E6%AF%94%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-text">（3）和IPv4相比的变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89IPv4%E5%88%B0IPv6%E7%9A%84%E8%BF%81%E7%A7%BB"><span class="toc-text">（4）IPv4到IPv6的迁移</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%80%9A%E7%94%A8%E8%BD%AC%E5%8F%91%E5%92%8CSDN"><span class="toc-text">四、通用转发和SDN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E4%B8%8ESDN%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">1.传统方式与SDN方式的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E7%94%A8%E8%BD%AC%E5%8F%91"><span class="toc-text">2.通用转发</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(https://bu.dusays.com/2024/11/27/6746e02939613.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 By ℡傲雪&星火ぴ</div><div class="footer_custom_text">有一天，我看了四十四次日落！你知道的，当一个人情绪低落的时候，他会格外喜欢看日落。 —— 《小王子》</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://aoxue-comment.tateishishima.site/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://aoxue-comment.tateishishima.site/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="/js/sakura.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://aoxuexinghuo.github.io/categories/Vue/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">‍💻 Vue2个人笔记 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://aoxuexinghuo.github.io/categories/计算机网络/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 计算机网络 自顶向下 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://aoxuexinghuo.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'ea2b00590ba4488f89eeaefab94b786e';
  var gaud_map_key = 'b057b1c862da771d963eb58645fde0ba';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.6534116,27.96920845';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/09/22/《计算机网络 自顶向下方法》笔记：第一章 计算机网络和因特网/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/27/6746dee5408d3.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-12-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/09/22/《计算机网络 自顶向下方法》笔记：第一章 计算机网络和因特网/&quot;);" href="javascript:void(0);" alt="">《计算机网络 自顶向下方法》笔记：第一章 计算机网络和因特网</a><div class="blog-slider__text">有种高中生物的美。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/09/22/《计算机网络 自顶向下方法》笔记：第一章 计算机网络和因特网/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/09/21/Vue学习笔记（一）：模版语法、条件渲染、列表渲染、key值管理/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/27/6746e01b2308a.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-12-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/09/21/Vue学习笔记（一）：模版语法、条件渲染、列表渲染、key值管理/&quot;);" href="javascript:void(0);" alt="">Vue学习笔记（一）：模版语法、条件渲染、列表渲染、key值管理</a><div class="blog-slider__text">建议直接去学最新的Vue3。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/09/21/Vue学习笔记（一）：模版语法、条件渲染、列表渲染、key值管理/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/11/27/博客优化日志/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/30/674ae885d9695.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-12-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/11/27/博客优化日志/&quot;);" href="javascript:void(0);" alt="">博客优化日志</a><div class="blog-slider__text">记录对博客的修改，目前看起来还是很塑料。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/11/27/博客优化日志/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/11/11/英语翻译练习/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "https://bu.dusays.com/2024/11/28/6748473533994.jpeg" data-lazy-src="https://bu.dusays.com/2024/11/30/674ae88cdbcd7.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-12-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/11/11/英语翻译练习/&quot;);" href="javascript:void(0);" alt="">英语翻译练习</a><div class="blog-slider__text">整理的一些英语翻译练习。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/11/11/英语翻译练习/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>