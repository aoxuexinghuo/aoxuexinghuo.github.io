---
title: 操作系统 第三章 内存管理
date: 2025-04-07 14:54:21
category: 操作系统
tags:
  - 操作系统
  - 408
cover: https://bu.dusays.com/2025/03/27/67e5014a4ac08.jpg
series: OS
---

> **🚥操作系统 系列文章导航🚥**
>
> {% series OS %}

## 一、内存管理概念

### 1.内存管理的功能

内存管理的主要功能有：

- **内存空间的分配与回收**。
- **地址转换**。
- **内存空间的扩充**。
- **内存共享**。指允许多个进程访问内存的同一部分。
- **存储保护**。保证各个进程在各自的存储空间内运行，互不干扰。

> **注意**：并不是所有的进程内存都适合共享，只有那些只读的区域才可以共享。**可重入代码**也称**纯代码**，是一种允许多个进程同时访问但不允许被任何进程修改的代码。但在实际执行时，也可为每个进程配以局部数据区，将在执行中可能改变的部分复制到该区域，这样，程序在执行时只需对该私有数据区域中的内存进行修改，并不去改变共享的代码。

### 2.程序的链接与装入

将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：

- **编译**：由编译程序将用户源代码编译成若干目标模块。
- **链接**：由链接程序将编译后形成的一组目标模块，以及它们所需的库函数链接在一起，形成一个完整的装入模块。
- **装入**：由装入程序将装入模块装入内存运行。

<img src="https://bu.dusays.com/2025/04/08/67f4d5bae1adc.png" alt="image-20250408151348813" style="zoom:67%;" />

将一个装入模块装入内存时，有以下三种装入方式：

**（1）绝对装入**（单道程序阶段，无操作系统）

**绝对装入**方式只适用于**单道程序环境**。在编译时，若知道程序将放到内存的哪个位置，则**编译程序**将产生绝对地址的目标代码。

装入程序按照装入模块中的地址，将程序和数据装入内存。程序中的逻辑地址与实际地址完全相同，因此不需对程序和数据的地址进行修改。

**（2）可重定位装入**（早期多道批处理阶段）

**可重定位装入**也称**静态重定位**。经过编译、链接后的装入模块的地址都是从 0 开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行**重定位**，将逻辑地址变换为物理地址（地址变换是在**装入时一次完成**的）。

**特点**：是在一个作业装入内存时，**必须分配其要求的全部内存空间**，如果没有足够的内存，就不能装入该作业。作业一旦进入内存，整个运行期间就**不能在内存中移动**，也不能再申请内存空间。

**（3）动态运行时装入**（现代操作系统）

**动态运行时装入**也称**动态重定位**。经过编译、链接后的装入模块的地址都是从 0 开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是**把地址转换推迟到程序真正要执行时才进行**。因此装入内存后的所有的地址依然是逻辑地址。这种方式需要一个**重定位寄存器**（存放装入模块的起始位置）的支持。

**优点**：①可以将程序分配到不连续的存储区。②在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存。③便于程序段的共享。

对目标模块进行连接时，根据链接的时间不同，分为三种连接方式：

- **静态链接**：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。
- **装入时动态链接**：将各目标模块装入内存时，采用边装入边链接的方式。其优点是便于修改和更新，便于实现对目标模块的共享。
- **运行时动态链接**：在程序执行中需要某目标模块时，才对它进行链接。凡在程序执行中未用到的目标模块，都不会被调入内存和链接到装入模块上。其优点是能加快程序的装入过程，还可节省内存空间。

> **疑惑**：在看王道视频时，咸鱼把便于修改和更新、便于实现对目标模块的共享归为运行时动态链接的优点，而王道书上却把其归为装入时动态链接的优点。Deepseek 给出的答案则是为前者：
>
> |       **特性**       |      **运行时动态链接**      |     **装入时动态链接**     |     **静态链接**     |
> | :------------------: | :--------------------------: | :------------------------: | :------------------: |
> | **修改和更新便利性** |      高（无需重启程序）      |    中（需重新装入程序）    | 低（需重新编译程序） |
> |   **模块共享能力**   | 高（多进程共享同一物理内存） | 中（依赖操作系统内存管理） |  无（代码重复嵌入）  |

### 3.存储保护

内存保护可采取两种方法：

**方法一**：在 CPU 中设置一对**上、下限寄存器**，存放用户进程在主存中的上、下限地址。每当 CPU 要访问一个地址时，分别和两个寄存器的值相比，判断有无越界。

<img src="https://bu.dusays.com/2025/04/08/67f503d005c88.png" alt="image-20250408190143223" style="zoom: 67%;" />

**方法二**：采用**重定位寄存器**（也称**基地址寄存器**）和**界地址寄存器**（也称**限长寄存器**）进行越界检测。重定位寄存器中存放的是进程的起始物理地址，界地址寄存器中存放的时进程的最大逻辑地址。内存管理部件将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再交送内存单元。

<img src="https://bu.dusays.com/2025/04/08/67f503d61c262.png" alt="image-20250408145445690" style="zoom:50%;" />

加载重定位寄存器和界地址寄存器时必须使用**特权指令**，只有**操作系统内核**才可以加载这两个寄存器。

## 二、连续分配管理方式

**连续分配**方式是指为一个用户程序分配一个连续的内存空间。连续分配方式主要包括单一连续分配、固定分区分配和动态分区分配。

### 1.单一连续分配

**单一连续分配**中，内存被分为**系统区**和**用户区**。系统区仅供操作系统使用，通常在低地址部分；用户区内存中仅有**一道**用户程序，即用户程序独占整个用户区。

- **优点**：简单、无外部碎片；不需要进行内存保护，因为内存中永远只有一道程序。
- **缺点**：只能用于单用户、单任务的操作系统中；有内部碎片；内存的利用率极低。

<img src="https://bu.dusays.com/2025/04/09/67f6223a2ec89.png" alt="image-20250409143204883" style="zoom: 33%;" />

### 2.固定分区分配

将整个用户空间划分为若干个**固定大小**的分区，在每个**分区**中只装入**一道**作业，这样就形成了最早、最简单的一种可运行多道程序的内存管理方式。

在划分分区时有两种不同的方法：

- **分区大小相等**：程序太小会造成浪费，程序太大又无法装入，缺乏灵活性。
- **分区大小不等**：划分为多个较小的分区、适量的中等分区和少量大分区。

<img src="https://bu.dusays.com/2025/04/09/67f6223e5494e.png" alt="image-20250409143733123" style="zoom: 50%;" />

操作系统需要建立一个数据结构——**分区说明表**，来实现各个分区的分配与回收。每个表项对应一个分区，通常按**分区大小排列**。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。

<img src="https://bu.dusays.com/2025/04/09/67f622426c09c.png" alt="image-20250409144401314" style="zoom: 50%;" />

- **优点**：实现简单，无外部碎片。
- **缺点**：①当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能。②会产生内部碎片，内存利用率低。

### 3.动态分区分配

**动态分区分配**又称为**可变分区分配**。这种分配方式**不会预先划分内存分区**，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

动态分区分配没有内部碎片，但是有外部碎片。

- **内部碎片**：分配给某进程的内存区域中，有些部分没有用上。
- **外部碎片**：指内存中的某些空闲分区由于太小而难以利用。

<img src="https://bu.dusays.com/2025/04/09/67f62246b3b01.png" alt="image-20250409145515347" style="zoom: 80%;" />

外部碎片可以通过**紧凑技术**来克服，即操作系统不时地对进程进行移动和整理。但是，这需要**动态重定位寄存器**（动态重定位的方式装入）的支持，且相对费时。

**问题一**：系统要用什么样的数据结构记录内存的使用情况？

- **空闲分区表**：每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息。
- **空闲分区链**：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息。

<img src="https://bu.dusays.com/2025/04/09/67f62252cef89.png" alt="image-20250409145942136" style="zoom: 50%;" />

**问题二**：当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？

把一个新作业装入内存时，须按照一定的**动态分区分配算法**，从空闲分区表（或空闲分区链）中选出一个分区分配给改作业。

**问题三**：如果进行分区的分配与回收操作？

以空闲分区表为例：

![image-20250409150404289](https://bu.dusays.com/2025/04/09/67f62257069df.png)

**进行分配时**：

①如果从分区 1 的 20 MB 空闲分区中摘出 4 MB 分配给一个进程，只需修改对应分区的分区大小和起始地址即可。

![image-20250409150553034](https://bu.dusays.com/2025/04/09/67f6225bc9730.png)

②如果将分区 3 的 4 MB 空闲分区全部分配给一个进程，则空闲分区的数量会减一，需要把这个分区对应的表项删除。

![image-20250409150829510](https://bu.dusays.com/2025/04/09/67f6225f3d8eb.png)

**进行回收时**：

①回收区的后面有一个相邻的空闲分区，则将两个相邻的空闲分区合并为一个。

![image-20250409151059226](https://bu.dusays.com/2025/04/09/67f6226277916.png)

②回收区的前面有一个相邻的空闲分区，也是将两个相邻的空闲分区合并为一个。

![image-20250409151231837](https://bu.dusays.com/2025/04/09/67f62265e85db.png)

③回收区的前、后各有一个相邻的空闲分区，则将三个相邻的空闲分区合并为一个。

![image-20250409151657667](https://bu.dusays.com/2025/04/09/67f62268f3f35.png)

④回收区的前、后都没有相邻的空闲分区，新增一个表项。各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定。

![image-20250409151938971](https://bu.dusays.com/2025/04/09/67f6226e582c5.png)

上述三种内存分区管理方法有一个共同特点，即用户程序在主存中都是**连续存放**的。

### 4.动态分区分配算法（基于顺序搜索）

**动态分区分配算法**：在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？

#### （1）首次适应算法（First Fit）

**算法思想**：每次都从地址值开始查找，找到第一个能满足大小的空闲分区。

**如何实现**：空闲分区以**地址递增次序**排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。

#### （2）最佳适应算法（Best Fit）

**算法思想**：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当 “大进程” 到来时能有连续的大片空间，可以尽可能地多留下大片的空闲区，即，优先使用更小的空闲区。

**如何实现**：空闲分区按**容量递增次序**链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。

**缺点**：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生**最多的外部碎片**。算法开销大，回收分区后可能需要对空闲分区队列重新排序。

#### （3）最坏适应算法（Worst Fit）

又称**最大适应算法（Largest Fit）**

**算法思想**：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。

**如何实现**：空闲分区按**容量递减次序**链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。

**缺点**：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，**最不容易产生外部碎片**，但是这种方式会导致较大的连续空间区被迅速用完。如果之后有大进程到达，就没有内存分区可用了。算法开销大，回收分区后可能需要对空闲分区队列重新排序。

#### （4）邻近适应算法（Next Fit）

又称**循环首次使用算法**

**算法思想**：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。

**如何实现**：空闲分区以**地址递增次序**排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。

**缺点**：让低地址、高地址部分的空闲分区以同等概率被分配，划分为小分区，导致内存高地址部分没有大空闲分区可用。

综合来看，**首次适应算法**的开销小，性能最好，回收分区也**不需要对空闲分区重新排序**（白眼）。

### 5.动态分区分配算法（基于索引搜索）

系统很大时，空闲分区链很长，采用顺序分配算法很慢。因此，大、中型系统中往往采用**索引分配算法**。

**索引分配算法**的核心思想是，根据大小对空闲分区进行分类，对于每类（大小相同）空闲分区，单独设立一个空闲分区链，并设立一张**索引表**来管理这些空闲分区链。

索引分配算法有如下三种：

- **快速适应算法**：空闲分区的分类根据进程常用的空间大小进行划分。分配过程分为两步：①首先根据进程的长度，在索引表中找到能容纳它的最小空闲分区链表。②然后从链表中取下第一块进行分配。优点是查找效率高、**不会产生内部碎片**；缺点是回收分区时，需要有效地**合并**分区，算法比较复杂，系统开销较大。
- **伙伴系统**：规定所有分区的大小均为 2 的 k 次幂（k 为正整数）。当需要为进程分配大小为 n 的分区时（2 的 i-1 次幂 < n < 2 的 i 次幂），在大小为 2^i 的空闲分区链中查找。若找到，则将该空闲分区分配给进程。否则，表示该大小的空闲分区已耗尽，需在大小为 2^(n+1) 的空闲分区链中继续查找。若存在，则将其等分为两个分区，这两个分区称为**一对伙伴**，其中一个用于分配，而将另一个加入大小为 2^i 的空闲分区链。若不存在，则继续查找，直到找到为止。回收时，需要**将相邻的空闲伙伴分区合并**成更大的分区。
- **哈希算法**：根据空闲分区链表的分布规律，建立哈希函数，构建一张以空闲分区大小为关键字的哈希表，每个表项记录一个对应空闲分区链的头指针。分配时，根据所需分区大小，通过哈希函数计算得到哈希表中的位置，从中得到相应的空闲分区链表。

> **疑惑**：快速适应算法不会产生内部碎片，果真吗哥们？

## 三、非连续分配管理方式

**连续分配**

### 1.基本分页存储管理

#### （1）基本概念

固定分区会产生内部碎片，动态分区会产生外部碎片。为了尽量避免碎片的产生，引入了分页的思想。

将内存分为一个个**大小相等的分区**，每个分区就是一个**页框**（也叫**页帧**、**内存块**、**物理块**、**物理页面**）。每个页框有一个编号，即**页框号**（也叫**页帧号**、**内存块号**、**物理块号**、**物理页号**），页框号**从 0 开始**。

将**进程的逻辑地址空间**也分为**与页框大小相等**的一个个部分，每个部分称为一个**页**或**页面**。每个页面也有一个编号，即**页号**，页号也是**从 0 开始**。

操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。

各个页面不必连续存放，可以放到不相邻的各个页框中。

<img src="https://bu.dusays.com/2025/04/10/67f780b63afd7.png" alt="image-20250410145402941" style="zoom: 50%;" />

某个分页存储管理的逻辑地址结构如下图：

![image-20250410151357465](https://bu.dusays.com/2025/04/10/67f780bbb4800.png)

地址包含两部分：前一部分为**页号 P**，后一部分为**页内偏移量 W**。地址长度为 32 位，其中 0-11 位为页内地址，即每页大小为 2^12 B（注意单位是**字节**）。12-31 位为页号，即最多允许 2^20 页。

为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张**页表**（页表通常存在 **PCB 进程控制块**中）。

![image-20250410151704866](https://bu.dusays.com/2025/04/10/67f780bf288ab.png)

因为页表项连续存放，因此页号可以是**隐含的**，**不占存储空间**（类比数组）。页表项的存放地址 = 页表起始地址 + 页表项大小 * 页号

#### （2）地址转换

![image-20250410154924487](https://bu.dusays.com/2025/04/10/67f780c276d55.png)

为了方便地址转换，页面的大小应是 2 的整数次幂：

![image-20250410154243280](https://bu.dusays.com/2025/04/10/67f780c66aada.png)

#### （3）基本地址变换机构

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。

通常会在系统中设置一个**页表寄存器（PTR）**，存放页表在内存中的**起始地址 F** 和**页表长度 M**。

进程未执行时，页表的始址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核才会把它们放到页表寄存器中。

![image-20250410161219878](https://bu.dusays.com/2025/04/10/67f780ccd61fb.png)

**两次访存操作**：第一次查页表，第二次访问目标内存单元。

> **注意**：页号 P 和页表长度 M 相等时也会越界，因为页号是从 0 开始的，而页表长度至少是 1。

在页式管理的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，**页式管理中地址是一维的**。即只要给出一个逻辑地址，系统就可以自动算出页号、页内偏移量两个部分（物理地址），并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。

对于页表项大小的确定，尝尝选择更大的页表项，让一个页面刚好能容纳整个页表项，或便于增加一些其他信息：

![image-20250410182015528](https://bu.dusays.com/2025/04/10/67f7a1d17c767.png)

#### （4）具有快表的地址变换机构

**快表**，又称**联想寄存器（TLB，translation lookaside buffer）**，是一种访问速度比内存快很多的**高速缓存**（属于**相联存储器**），用来存放最近访问的页表项的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为**慢表**。

![image-20250410184230548](https://bu.dusays.com/2025/04/10/67f7a1d6e1fa7.png)

快表的有效性基于局部性原理。若快表命中，则只需要**一次访存**即可完成逻辑地址的访问，否则仍需两次。

有的系统支持快表慢表同时查找：

<img src="https://bu.dusays.com/2025/04/10/67f7c70e42088.png" alt="image-20250410185221581" style="zoom: 50%;" />

**TLB 和普通 Cache 的区别**：TLB 中只有页表项的副本，而普通 Cache 中可能会有其他各种数据的副本。

#### （5）两级页表

单级页表存在的问题：

- **问题一**：**页表必须连续存放**，因此当页表很大时，需要占用很多个连续的页框。
- **问题二**：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。

对于问题一，可将页表进行分区，使每个内存块刚好可以放入一个分组。再将各组离散地放到各个内存块中。另外，要为离散分配的页表再建立一张页表，称为**页目录表**，或称**外层页表**，或称**顶层页表**。

![image-20250410211209416](https://bu.dusays.com/2025/04/10/67f7c713392dc.png)

为了方便实现地址转换，需要在系统中增设一个**外层页表寄存器**（也称**页目录基址寄存器**），用于存放页目录始址。

**注意事项**：

- 若采用多级页表机制，则各级页表的大小不能超过一个页面。
- 两级页表需要三次访存（假设没有快表机构）：①访问内存中的页目录表。②访问内存中的二级页表。③访问目标内存单元。

对于问题二，可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存。若想访问的页面不在内存中，则产生缺页中断（内中断），然后将目标页面从外存调入内存。

### 2.基本分段存储管理

#### （1）基本概念

- **分页管理方式**是从计算机的角度考虑设计的，目的是提高内存的利用率，提升计算机的性能。分页通过**硬件**实现，对用户完全**透明**。**页是信息的物理单位**。
- **分段管理方式**的提出则考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。分段对用户是**可见**的。**段是信息的逻辑单位**。

**分段**：将进程的地址空间按照程序**自身的逻辑关系**划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从 0 开始编址。

**内存分配规则**：以段为单位进行分配，每个段在内存中占据**连续空间**，但各段之间可以不相邻。

![image-20250411142638930](https://bu.dusays.com/2025/04/11/67f8b642e9245.png)

分段存储管理的**逻辑地址**结构由**段号** 和**段内偏移量** 两部分组成：

![image-20250411143222964](https://bu.dusays.com/2025/04/11/67f8b98b01d0f.png)

页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在分段系统中，段号和段内偏移量必须由用户**显式提供**，在高级程序设计语言中，这个工作由**编译程序**完成。

每个进程都有一张逻辑空间与内存空间映射的**段表**，进程的每个段对应一个**段表项**，段表项记录了该段在内存中的**始址**和段的**长度**。

![image-20250411143644538](https://bu.dusays.com/2025/04/11/67f8b99066c28.png)

因为段表项是连续存放的，且各个段表项的长度相同，因此段号是可以隐含的，**不占用存储空间**。

**分页管理的地址空间是二维**，需要显式给出段号和段内偏移才能确定对应的物理地址。因为每段的长度是不固定的，无法通过除法得出段号，无法通过求余得出段内偏移。

#### （2）地址变换

![image-20250411150332462](https://bu.dusays.com/2025/04/12/67fa1685ddde6.png)

**段表寄存器**用于存放段表始址 F 和段表长度 M。

段号和段内地址都需要进行越界检查。

分段管理系统同样可以引入快表机制。

#### （3）段的共享与保护

分段比分页**更容易**实现信息的共享和保护。

不能被修改的代码称为**纯代码**或**可重入代码**，这样的代码可以共享；可修改的代码不能共享。

为了防止程序在执行时修改共享代码，在每个进程中都必须配以**局部数据区**，将在执行过程中可能改变的部分复制到数据区，这样，进程就可对该数据区中的内容进行修改。

实现共享只需要让各进程的段表项指向同一个段即可：

![image-20250411152039234](https://bu.dusays.com/2025/04/11/67f8c3595f343.png)

> **注意**：在旧版教材中，采用的方法是，系统中会配置一张**共享段表**，所有共享的段都在该表中有一个表项。记录了共享段的段号、段长、内存始址、状态（存在）位、外存始址和共享进程计数 count 等信息。只有 count 为 0 时，才回收该段所占的内存区。对于一个共享段，在不同的进程中可以有不同的段号，每个进程用自己进程的段号去访问该共享段。

与分页管理类似，分段管理的保护方法主要有两种：一种是**存取控制保护**，一种是**地址越界保护**。

### 3.段页式存储管理

|              |                             优点                             |                             缺点                             |
| :----------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| **分页管理** | 内存空间利用率高，**不会产生外部碎片**，只会有少量的页内碎片 |            不方便按照逻辑模块实现信息的共享和保护            |
| **分段管理** |            很方便按照逻辑模块实现信息的共享和保护            | 如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理**会产生外部碎片** |

**段页式存储管理**综合了两者的优点：

![image-20250411155253142](https://bu.dusays.com/2025/04/11/67f8ca76159a9.png)

段页式系统的逻辑地址由**段号**、**页号**、**页内偏移量**三部分组成：

![image-20250411194015679](https://bu.dusays.com/2025/04/11/67f9061220687.png)

分段对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将各段分页对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此**段页式管理的地址结构式二维的**。

![image-20250411195920838](https://bu.dusays.com/2025/04/11/67f90617de336.png)

在段页式存储管理者，每个进程的段表只有一个，而页表可能有多个。

系统中还有一个**段表寄存器**，指出进程的**段表始址**和**段表长度**（段表寄存器和页表寄存器的作用都有两个，一是在段表或页表中寻址，二是判断是否越界）：

![image-20250411200519863](https://bu.dusays.com/2025/04/11/67f9061fa7fe8.png)

## 四、虚拟内存管理

### 1.定义和特征

对于前面讲到的传统存储管理（连续分配和非连续分配），它们都具有以下两个共同的特征：

- **一次性**：作业必须一次性全部装入内存后才能开始运行。这会导致①作业很大时，不能全部装入内存，导致大作业无法运行。②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。
- **驻留性**：一旦作业被装入内存，就会一直驻留在内存中，直至用户结束。会导致内存中驻留大量暂时用不到的数据。

**虚拟存储技术**实际上建立了 “内存-外存” 的两级存储器结构，利用局部性原理实现高速缓存。

- **请求调页功能**（或请求调段）：所访问信息不在内存时，由操作系统负责将所需信息从外存调入内存。
- **页面置换功能**（或段置换）：内存空间不够时，由操作系统负责将内存中暂时用不到的信息换出到外存。

虚拟存储系统的主要特征：

- **多次性**：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
- **对换性**：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
- **虚拟性**：从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际容量。

因为允许一个作业多次调入内存，因此虚拟内存的实现需要建立在**离散分配**的内存管理方式基础上，从而产生三种实现方式：

- **请求分页存储管理**
- **请求分段存储管理**
- **请求段页式存储管理**

### 2.请求分页管理方式

**请求分页管理方式**在传统的基本分页存储管理的基础上新增了**请求调页**和**页面置换**功能。

#### （1）页表机制

![image-20250412145041496](https://bu.dusays.com/2025/04/12/67fa0d5c00982.png)

请求页表的表项中新增了四个字段：

- **状态位**：标记该页是否已调入内存，供程序访问时参考。
- **访问字段**：记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，供置换算法换出页面时参考。
- **修改位**：标记该页在调入内存后是否被修改过，以决定换出时是否写回外存。
- **外存地址**：记录该页在外存的存放地址，通常是物理块号，供调入该页时参考。

#### （2）缺页中断机构

- 在请求分页系统中，每当要访问的页面不在内存时，便产生一个**缺页中断**，然后由操作系统的缺页中断处理程序处理中断。
- 此时缺页的进程**阻塞**，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。
- 如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。
- 如果内存中没有空闲块，则由**页面置换算法**选择一个页面淘汰，若该页面在内存期间被修改过，则要将其**写回外存**。未修改过的页面不用写回外存。

**缺页中断**在指令执行期间而非一条指令执行完成后产生和处理，因此属于**内部异常**中的**故障（Fault）**。

**一条**指令在执行期间，可能产生**多次**缺页中断。

#### （3）地址变换机构

在基本分页系统地址变换机构的基础上，为了实现虚拟存储，增加了产生和处理缺页中断，及从内存中换出一页的功能：

![image-20250412154049767](https://bu.dusays.com/2025/04/12/67fa195175c98.png)

1. 先检索快表，若命中，则从相应表项中取出该页的物理块号，并修改页表项中的**访问位**，以供置换算法换出页面时参考。对于**写指令**，还需要将**修改位**置 1。
2. 若快表未命中，则要到页表中查找，若找到，则从相应表项中取出物理块号，并将该页表项写入快表，若快表已满，则需采用某种算法替换。
3. 若在页表中未找到，则需要进行**缺页中断处理**，请求系统将该页从外存换入内存，页面被调入内存后，由**操作系统**负责更新**页表**和**快表**，并获得物理块号。
4. 利用得到的物理块号和页内地址拼接形成物理地址，用该地址去访存。

### 3.页面置换算法

#### （1）最佳置换算法（OPT）

**最佳置换算法（OPT，Optimal）**：每次选择淘汰的页面将是**以后永不使用**，或者**在最长时间内不再访问的页面**，这样可以保证最低的缺页率。

![image-20250412161112751](https://bu.dusays.com/2025/04/12/67fa20d212d11.png)

需要注意最长时间不被访问和以后被访问次数最小是两个不同的概念。

操作系统无法提前预判访问序列，因此最佳置换算法是无法实现的。

#### （2）先进先出置换算法（FIFO）

**先进先出置换算法（FIFO）**：每次选择淘汰的页面是**最早进入内存的页面**。

**实现方法**：把调入内存的页面根据调入的先和顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。

![image-20250412161832300](https://bu.dusays.com/2025/04/12/67fa22d9190a7.png)

![image-20250412161902902](https://bu.dusays.com/2025/04/12/67fa22db29674.png)

FIFO 算法会产生当为进程分配的物理块增多时，缺页次数**不减反增**的异常显现，称为 **Belady 异常**。

只有 FIFO 算法会出现这种情况，而 LRU 和 OPT 算法永远不会出现 **Belady 异常**。

该算法实现简单，但性能差。

#### （3）最近最久未使用置换算法（LRU）

**最近最久未使用置换算法（LRU，least recently used）**：每次淘汰的页面是**最近最久未使用的页面**。

**实现方法**：在每个页面对应的页表项中的**访问字段**记录该页面上次被访问以来所经历的时间 t。每当需要淘汰一个页面时，选择现有页面中 t 值最大的。

![image-20250412213301142](https://bu.dusays.com/2025/04/13/67fbb0761e35d.png)

该算法性能好，但是实现起来需要寄存器和栈的**硬件支持**，开销较大。

#### （4）时钟置换算法（CLOCK）

**①简单的 CLOCK 置换算法**

**实现方法**：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个**循环队列**。当某页面**被访问时**，其访问位**置为 1**。当需要淘汰一个页面时，只需检测页的访问位。如果是 0，就选择该页换出；如果是 1，则将它置为 0，**暂不换出**，继续检测下一个页面，若第一轮扫描中所有页面都是 1，则将这些页面的访问位依次置为 0 后，再进行第二轮扫描（第二轮扫描一定会有访问位为 0 的页面，因此简单的 CLOCK 算法选择一个淘汰页面**最多**会经过**两轮**扫描）。

#### （2）改进型的时钟置换算法

只有被淘汰的页面被修改过时，才需要写回外存。因此在其他条件都相同时，应**优先淘汰没有被修改过的页面**，避免 I/O 操作，这就是改进型的时钟置换算法的思想。

下面用（访问位，修改位）的形式表示各页面状态，如（1，1）表示一个页面近期被访问过，且被修改过。

**算法规则**：将所有可能被置换的页面排成一个循环队列

-  **第一轮**：从当前位置开始扫描到第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位。
- **第二轮**：若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的帧**访问位置为 0**。
- **第三轮**：若第二轮扫描失败，则重新扫描，查找第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位。
- **第四轮**：若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。

由于第二轮已将所有帧的访问位设为 0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型 CLOCK 置换算法选择一个淘汰页面**最多**会进行**四轮**扫描。

### 4.页面分配策略

#### （1）内存分配策略

**驻留集**：指请求分页存储管理中给进程分配的物理块的集合。

驻留集太小，会导致缺页频繁；驻留集太大，会导致多道程序并发度下降，资源利用率降低。

在请求分页系统中，可采取**固定**和**可变分配**两种策略。在进行置换时，可采取**全局**和**局部置换**两种策略。于是可组合出下面三种策略：

- **固定分配局部置换**：为进程分配固定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是：很难在刚开始就确定为每个进程分配多少个物理块才算合理。
- **可变分配全局置换**：刚开始为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个**未锁定**的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，**只要某进程发生缺页，都将获得新的物理块**，仅当空闲物理块用完时，系统才会选择一个未锁的的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个**被选中的进程拥有的物理块会减少，缺页率会增加**。
- **可变分配局部置换**：刚开始会为每个进程分配一定数量的物理块。当某进程发送缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地换页，系统会为该进程多分配几个物理块，直至该进程缺页率趋于适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。

> **注意**：全局置换意味着一个进程拥有的物理块数量必然会改变，因此不可能是固定分配。

采用固定分配策略时，可采用下述几种算法：

- **平均分配算法**：将系统中所有可供分配的物理块平均分配给各个进程。
- **按比例分配算法**：根据进程的大小按比例分配物理块。
- **优先权分配算法**：为重要和紧迫的进程分配较多的物理块。通常采用的方法是将所有可分配的物理块分成两部分，一部分按比例分配给各个进程，一部分则根据优先权分配。

#### （2）何时调入页面

为确定系统将进程运行时所缺的页面调入内存的时机，可采取以下两种调页策略：

- **预调页策略**：根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有 50% 左右。故这种策略**主要用于进程的首次调入**。
- **请求调页策略**：进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘 I/O 操作，因此 I/O 开销大。

预调页实际上就是**运行前**的调入，请求调页实际上就是**运行期间**的调入。

#### （3）从何处调入页面

请求分页系统的外存分为两部分：

**对换区**：用于存放对换页面，也称**交换区**，采用连续分配方式，I/O 速度快。

**文件区**：用于存放文件，采用离散分配方式，I/O 速度慢。

当发生缺页请求时，有一下三种情况：

**①系统拥有足够的兑换区空间**：页面的调入、调出都是在内存与兑换区之间进行，这样可以保证页面的调入、调出速度很快。在**进程运行前**，需将进程相关的数据从文件区复制到兑换区。

<img src="https://bu.dusays.com/2025/04/13/67fb6f083af67.png" alt="image-20250413150156295" style="zoom: 67%;" />

**②系统缺少足够的对换区空间**：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。

<img src="https://bu.dusays.com/2025/04/13/67fb6f0c65fee.png" alt="image-20250413152152648" style="zoom:67%;" />

**③UNIX 方式**：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。

<img src="https://bu.dusays.com/2025/04/13/67fb6f109c622.png" alt="image-20250413152543980" style="zoom:67%;" />

### 5.页框回收

#### （1）页面缓冲算法

**页面缓冲算法**在原页面置换算法的基础上增设已修改页面链表，保存已修改且需要被换出的页面，等被换出的页面数量达到一定值时，再一起换出到磁盘，以减少页面换出的开销。

**特点**：显著降低页面换入/换出的频率，使磁盘的 I/O 开销大为减少，进而减少页面换入/换出的开销；由于换入/换出的开销大幅减少，当其采用一种较为简单的置换策略（如 FIFO 页面置换算法）时，不需要特殊硬件的支持，实现起来非常简单。

为了降低换入换出频率，内存中设置了两个链表：

- **空闲页面链表**：也称**空闲页框链表**。当进程需要读入一个页面时，便从空闲页面链表中取链首的页框并装入该页。当有一个未被修改的页面要换出时，实际上并不将它换出到磁盘，而将它所在的页框挂在空闲链表的链尾。
- **修改页面链表**：当进程需要将一个已修改的页面换出时，系统并不立即将它换出到磁盘，而将它所在的页框挂在修改页面链表的末尾。目的是降低将已修改页面写回磁盘的频率，进而降低将磁盘内容读入内存的频率。

> **注意**：挂在空闲链表内且未被修改的页框是有数据的，若以后某个进程需要这些数据，则可从空闲链表上将它们取下，进而避免从磁盘读入的操作，减少页面换入的开销。

#### （2）页框回收

系统可分配内存不足时，需要回收页框。属于内核的大部分页框都是不能回收的，属于进程使用的页框大部分是可以回收的。

Linux 内核中，设置了一个负责页面换出的守护进程 kswapd，它定期检查内存的使用情况，当空闲页框数**少于特定阈值**时，便发起页框回收操作。设定阈值是为了避免无空闲页框时，内核陷入内存请求的僵局，导致系统崩溃。

Linux 系统采用**伙伴算法的逆操作**对页框进行回收。回收时，先检查是否有大小相等的伙伴页框存在，若有，则将它们合并成一个大小为原来两倍的新空闲页框块，每次合并完后，还要检查是否可以继续合并成更大的页框块。

### 6.内存映射文件

**内存映射文件（Memory-Mapped Files）** 是操作系统向应用程序提供的一个系统调用，可以①方便程序员访问文件数据，②方便多个进程共享同一个文件。

传统的文件访问方式：

![image-20250413154725997](https://bu.dusays.com/2025/04/13/67fb6f1528cd5.png)

内存映射文件的访问方式：

![image-20250413155205681](https://bu.dusays.com/2025/04/13/67fb6f30ef0dd.png)

采用内存映射文件，进程可以以访问内存的方式访问文件数据。磁盘文件的读写操作由**操作系统**完成（故操作系统可以采用一些优化策略，如预读入、缓写出等），对进程而言时透明的。且在映射进程的页面时，不会实际读入文件内容，**只在访问页面时才被每次一页地读入**。当进程退出或关闭时，所有被改动的页面才被写回磁盘文件。

该系统调用还可以用来实现进程间**共享内存**：映射相同文件到通信进程的虚拟地址空间。一个进程在共享内存上完成了写操作，此刻当另一个进程再映射到这个文件的虚拟地址空间上执行读操作时，就能立刻看到上一个进程写操作的结果。

<img src="https://bu.dusays.com/2025/04/13/67fb6f345d4f7.png" alt="image-20250413155635432" style="zoom:50%;" />







