---
title: 《计算机网络 自顶向下方法》笔记：第五章 网络层：控制平面
date: 2024-10-24 10:05:22
mathjax: true
category: 计算机网络
tags:
  - 计算机网络
  - 笔记
series: TopDown
---

> **🚥计算机网络 自顶向下方法 系列文章导航🚥**
>
> {% series TopDown %}
>

## 一、概述

### 1.传统方式与SDN方式

在上一章的学习里我们了解到转发表（基于目的的转发）和流表（通用转发）是链接网络层的数据平面和控制平面的首要元素。这些表定义了一台路由器的本地数据平面转发行为，而在通用转发下，所采取的动作还包括丢弃一个分组、复制一个分组和重写第2、3或4层分组首部字段。

在本章中，我们将关注这些转发表和流表是如何计算、维护和安装的。实际上我们已经了解到在传统方式下和 SDN 方式下完成这些工作的两种方法，前者是由每个路由器完成，后者则是远程集中控制路由，路由器仅执行转发功能（当然还包括流表支持的一些其他动作，这些其他的动作以前都是由单独的中间盒实现的）。

我们可以根据下面两张图来回忆一下两种方式的区别：

<img src="https://bu.dusays.com/2024/11/26/67457d1da10d4.png" alt="1" style="zoom: 50%;" />

<img src="https://bu.dusays.com/2024/11/26/67457d285f5ef.png" alt="2" style="zoom: 50%;" />

### 2.传统方式的路由机制

而传统方式（区别于SDN）的路由机制又分为两个级别：**内部网关协议（IGP，Interior Gateway Protocol）** 和**外部网关协议（EGP, Exterior Gateway Protocol）**。它们承担不同范围内的路由任务，以确保数据包能够从源节点到达目标节点。

**内部网关协议IGP**用于自治系统（AS，Autonomous System）内部的路由，自治系统是由单一结构控制的一组路由器和网络。常见的IGP协议有：OSPF、RIP等。

**外部网关协议EGP**用于自制系统之间的路由（如互联网服务提供商ISP之间的路由），EGP确保来自一个AS的数据能够正确传递到其他AS。常见的EGP协议有：**BGP（Border Gateway Protocol）**。BGP是目前互联网的核心路由协议，负责管理AS之间的路由。

## 二、路由选择算法

### 1.前置信息

**路由**：按照某种指标（传输延时，所经过的站点数据等）找到一条从源节点到目标节点的较好的路径。

路由是以网络为单位进行的，这样路由信息传输、计算和匹配的代价更低。

路由选择算法是网络层的重要组成部分，用于完成路由功能，遵循以下原则：

- 正确性（correctness）：算法必须是正确和完整的。
- 简单性（simplicity）：最优但复杂的算法，时间上延迟很大，不能为了获取路由信息而增加很多通信量。
- 健壮性（robustness）：算法能够适应通信量和网络拓扑的变化（究竟是谁把这个词翻译成鲁棒性的）。
- 稳定性（stability）：产生的路由不应该摇摆。
- 公平性（fairness）：对每一个站点都公平
- 最优性（optimality）：某一个指标的最优，可以是时间、费用或综合指标等（实际上，获取最优的结果代价较高，一般是次优的）。

路由选择算法可以分为**集中式路由选择算法（centralized routing algorithm）** 和 **分散式路由选择算法（decentralized routing algorithm）**：

- **集中式路由选择算法**：所有的路由都拥有完整的拓扑和边的代价的信息，这样的算法被称作**链路状态（Link State，LS）算法**。
- **分散式路由选择算法**：路由器只知道与它有物理连接关系的邻居路由器，和到相应邻居路由器的代价，通过迭代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或一组目的节点的最低开销路径，这样的算法被称为**距离向量（Distance-Vector，DV）算法**。

路由选择算法的第二种分类方式是根据算法是静态的还是动态度进行分类。在**静态路由选择算法（static routing algorithm）** 中，路由随时间的变化非常缓慢，通常是人工进行调整；在**动态路由选择算法（dynamic routing algorithm）** 中，会随着网络流量负载或拓扑发生变化而改变路由选择路径。

路由选择算法的第三种分类方式是根据它是负载敏感的还是负载迟钝的进行划分。在**负载敏感算法（load-sensitive algorithm）** 中，链路开销会动态地变化以反映出底层链路的当前拥塞水平。如果当前拥塞的一条链路与高开销相联系，则路由选择算法趋向于绕开该拥塞链路来选择路由。而但如今的因特网路由算法（RIP、OSPF和BGP）都是**负载迟钝（load-insensitive）** 的，因为某条链路的开销并不能明确地反映拥塞水平。

### 2.链路状态路由选择算法

#### （1）实现方式

在LS算法中，网络拓扑和链路开销都是已知的，基于这些信息，使用**Dijkstra算法**计算出最短路径，从而得到路由表。

具体工作流程为：

1. 发现相邻节点，获取对方网络地址
2. 检测到相邻节点的代价（延迟、开销）
3. 组装一个LS分组，描述它到相邻节点的代价情况
4. 将分组通过洪泛的方式发到所有其他路由器
5. 通过Dijkstra算法找出最短路径

前四步都是为了让每个路由器获得拓扑和边代价，最后一步才是路由算法。其中第四步会有一些限制方式防止分组无穷地扩散：

- 顺序号（Sequence Number）：每个LS分组都带有一个顺序号，表示该分组的版本，而路由器会记录（源路由器，顺序号）的组合，当收到重复或者老版本的分组后，直接丢弃不在转发。
- 年龄字段（Age）：生成一个分组是，为其设置一个不为0的年龄字段，每过一个时间段（不是跳数）年龄字段就减1，年龄字段为0的分组将被抛弃。


#### （2）Dijkstra算法

**Dijkstra算法**是一种用于计算单源最短路径的经典算法，能够找到从某个节点到其他所有节点的最短路径。

算法的核心思想是：从源节点开始，每次选择当前路径开销最小的节点，并更新与其相邻节点的距离，直到所有节点都被访问完毕。

我们以下图为例使用Dijkstra算法计算从 **u** 到达其他其他所有可能目的地的最低开销路径：

<img src="https://bu.dusays.com/2024/11/26/67457d35bd227.png" alt="3" style="zoom:50%;" />

| 步骤 |   N'   | D(v), p(v) | D(w), p(w) | D(x), p(x) | D(y), p(y) | D(z), p(z) |
| :--: | :----: | :--------: | :--------: | :--------: | :--------: | :--------: |
|  0   |   u    |    2, u    |    5, u    |    1, u    |     ∞      |     ∞      |
|  1   |   ux   |    2, u    |    4, x    |            |    2, x    |     ∞      |
|  2   |  uxy   |    2, u    |    3, y    |            |            |    4, y    |
|  3   |  uxyv  |            |    3, y    |            |            |    4, y    |
|  4   | uxyvw  |            |            |            |            |    4, y    |
|  5   | uxyvwz |            |            |            |            |            |

上表中，N'表示确定的最短路径的点；D()表示目前已知的从u点到该点的最短路径长度；P()表示在已知最短路径下，该点的上一跳的位置。

- 初始状态下，已知u距离本身的最短路径为零，将u放入N'中。与u直连的v，w，x到达u的距离分别为2、5、1，他们的上一跳均为u。不与u直连的点，D()暂且置为∞。

- 第1步，观察还未加入N'中的点，选取D()值最小的点，将其加入N'。这里D(x)=1最小，我们将x加入N'里。然后观察与x直连的点有v、w、y（排除已经加入N'的点）。如果以x作为终点的上一跳，源点达到这三个点的最短路径为D'(v)=D(x)+2=3、D'(w)=D(x)+3=4、D'(y)=D(x)+1=2，将得到的新值与原有的D(v)、D(w)、D(y)进行比较，发现D'(w)小于D(w)，因此我们把D(w)的值更新为4，p(w)更新为x；D'(y)小于D(y)，因此我们把D(y)的值更新为2，p(y)更新为x。

- 第2步，观察还未加入N'中的点，选取D()值最小的点，将其加入N'。我们发现D(v)=D(y)=2，两者均为最小值，我们任选其一即可。这里选择先将y加入N'里。然后观察与y直连的点有w和z。如果以y作为终点的上一跳，源点达到这两个点的最短路径为D'(w)=D(y)+1=3、D'(z)=D(y)+2=4，我们将得到的新值与原有的D(w)、D(z)进行比较，发现D'(w)小于D(w)，因此我们把D(w)的值更新为3，p(w)更新为y；D'(z)小于D(z)，因此我们把D(z)的值更新为4，p(z)更新为y。

- 第3步，观察还未加入N'中的点，选取D()值最小的点，将其加入N'。这里D(v)=2最小，我们将v加入N'里。然后观察与v直连的点有w。如果以v作为终点的上一跳，源点到达w的最短路径为D'(w)=D(v)+3=5。D'(w)大于D(w)，不做处理（如果相等，也不做处理）。

- 第4步，观察还未加入N'中的点，选取D()值最小的点，将其加入N'。这里D(w)=3最小，我们将w加入N'里。然后观察与w直连的点有z。如果以w作为终点的上一跳，源点达到z的最短路径为D'(z)=D(w)+5=8。D'(z)大于D(z)，不做处理。

- 第5步，此时仅剩余z点，直接将z点加入N'里，得到最终的结果


Dijkstra算法在最坏情况下，每一次迭代都要检查所有不在N'中的点，所以要进行：
$$
(n - 1) + (n - 2) + \cdots + 1 = \frac{(n - 1) n}{2}
$$
次比较，算法的时间复杂度为：**O(n^2 )**。

借助优先队列（通常使用最小堆）可帮助快速找到当前距离最小的节点并更新邻接节点的最短路径，从而将复杂度降低为**O(nlogn)**。对于每个节点从优先队列入队和出队的复杂度为O（logn），一共涉及n个节点，因此为O(nlogn)。

#### （3）路由选择的震荡

我们以下图为例解释路由选择的震荡：

<img src="https://bu.dusays.com/2024/11/26/67457d4109207.png" alt="4" style="zoom:67%;" />

已知链路的开销是非对称的，也就是说从v到u的代价与从u到v的代价不一定相同。初始状态如图a所示，z顺时针向w发送一个单位的流量；x逆时针向w发送一个单位的流量；y逆时针向w发送大小为e的流量。

当LS算法再次运行时，y发现顺时针到w的开销为1，逆时针到w的开销为1+e，于是选择改为顺时针发送。而x样发现了顺时针的开销更小，选择顺时针发送。于是变成了图b的状态。

当LS算法下次运行时，x、y、z又都被引导到了逆时针的方向，变成了图c的状态。

当LS算法再下次运行时，x、y、z又都被引导到了顺时针的方向，变成了图d的状态。

为了防止路由震荡，我们可以确保不是所有的路由器都同时运行链路状态（LS）算法。

### 3.距离向量路由选择算法

#### （1）实现方式

DV算法的基本思想是：

- 各路由器维护一张路由表，表项包括目标点，下一跳以及到达目标点所需的代价；
- 各路由器与相邻的路由器交换路由表； 
- 根据获得的路由信息，更新路由表；

> **注意**：路由表这三个表项的含义是，已知一条从自身到达目标点D的路径，该路径的代价为C，按照该路径行动时，源点的下一跳为N，则路由器会在路由表中记录下目标点D，下一跳N和代价C。如果在和相邻路由器交换信息的过程中发现了同目标代价更小的路径，则会按照同样的格式更新路由表。

而最低开销路径的计算则要借助于著名的**Bellman-Ford方程**：
$$
d_x(y) = min_{v} \{ c(x, v) + d_v(y) \}
$$
方程中的min_v是对于x的所有邻居，c(x，y)表示从x到v的代价。d_v(y)表示从v到目标y的代价，d_x(y)表示从x到目标y的代价，让我们带着这个方程来观察下面这张图：

![5](https://bu.dusays.com/2024/11/26/67457d4b53eef.png)

- 以图中的节点J为例，J的相邻节点为A、I、H、K，然后J测得到这四个点的延迟分别为8ms、10ms、12ms、6ms；
- 通过交换路由Bellman-Ford方程表，从A、I、H、K那里分别获得它们到达G的延迟为18ms、31ms、6ms、31ms；
- 利用Bellman-Ford方程计算出J经过这四个点到达G的延迟分别为26ms、41ms、18ms、37ms，选择延迟最小的H点，18ms更新到自己的路由表中。
- 计算其他目标点同理，但要注意排除自己本身J点（不然会计算出奇怪的东西doge）

相较于集中式的LS算法，**DV算法是一种迭代的、异步的和分布式的算法。**

- “分布式”是因为每个节点都要从一个或多个直接相连临节点接收某些信息，执行计算然后将计算结果分发给邻居；
- “迭代”是因为这个过程一直要持续到邻居之间无更多的信息要交换位置（此算法是自我终结的，即不需要外部的明确终止信号，当邻居之间没有更多的更新消息需要交换时，算法就会停止）；
- “异步”是因为它不要求所有的节点相互之间步伐一致地操作。

每个节点会在**等待**、**重新计算**和**通告**这三种状态之间循环切换：

<img src="https://bu.dusays.com/2024/11/26/67457d55dd1ad.png" alt="6" style="zoom: 50%;" />

#### （2）DV的无穷计算问题

**DV具有好消息传的快，坏消息传的慢的特点。**

好消息的传播以每一个交换周期前进一个路由器的速度进行：

<img src="https://bu.dusays.com/2024/11/26/67457d66e3ac6.png" alt="7" style="zoom:67%;" />

以上图为例，这里以跳数来代表代价，初始状态下A到其他点均不可达。然后我们连接A点和B点，这时B点的路由表上会更新出到达A点代价为1的一条路径。通过信息交换，C点从B点得到了这个信息，在自己的路由表上更新了到达A点代价为2的路径。然后按照这种方式再依次传递给D点，E点。

而坏消息的传播速度就非常慢，存在**路由选择环路（routing loop）**：

<img src="https://bu.dusays.com/2024/11/26/67457d6f50a95.png" alt="8" style="zoom:67%;" />

以上图为例，初始状态下链路完整，节点下的数字代表其到A点的跳数。假设A到B的链路意外中断，此时B检测到A不可达，更新自己的路由表。然后在第一次信息交换后，C点向B点表示自己有一条代价为2的路径可达A点，于是B更新自己的路由表，将到达A的代价从无穷修改为2+1=3（然而C点所谓的可达A点的路径，下一跳正是B点自己，憋笑.jpg）。于是B点认为A点可达，向A点发送信息时，选择C点作为下一跳，而C点记录的下一跳是B点，于是又将数据发回B点，就像这样形成了回路。只有当下一次信息交换时，各自再更新到达A点的代价为Min(left，right)+1，如此往复循环，无限次后，到达A的距离变为无穷大，不可达。

#### （3）水平分裂算法和毒性逆转

**水平分裂（split horizon）算法**是一种对无穷计算问题的解决方法。

重新使用我们在坏消息传的慢的例子中所构建的场景，当A到B的链路意外中断后，开始第一次信息交换。此时C点向B点发送自己的信息时，因为它知道自己到达A的下一跳就是B，于是选择不在B面前班门弄斧，把自己到达A的路径藏起来，告诉B自己不可达A。但是C点向D点发送自己的信息时，则是正常地把自己记录的到达A点的距离传达出去，通过这种方式来避免回路的产生，A点不可达的坏消息以一次交换一个节点的速度向外传播。我们将这种不将从某个邻居学到的路由信息通过同一个接口再返回给该邻居的算法称之为水平分裂算法，《自顶向下》这本书上也将其称之为**毒性逆转（Poison Reverse）**。

但实际上，水平分裂算法并没有解决一般的无穷计数问题，例如涉及3个或更多节点（而不只是两个直接相连的邻居节点）的环路：

<img src="https://bu.dusays.com/2024/11/26/67457d765c4f1.png" alt="9" style="zoom:80%;" />

在这张图中，如果CD之间的路径失效了，C获知D不可达。在信息交换后从AB处获得的信息也为D不可达，因此认为D不可达。但是A从C处获得D不可达的同时，又从B处得知B到D的距离为2，于是认为自己到D的距离为3。点B也同理，经过无限次信息交换后，AB才知道D不可达。

### 4.LS与DV路由选择算法的比较

**报文复杂性（DV复杂度更低）**：LS算法要求每个节点知道网络中每条链路的开销，这就要求发送O（|N| |E|）个报文（N个节点，E条链路），而DV只需要相邻连接的点直接交换报文。

**收敛速度（LS收敛速度更快）**：LS算法的实现是一个要求O（|N| |E|）个报文的时间复杂度为O（N_2）的算法，可能遇见路由震荡的问题；而DV算法收敛较慢，且在收敛时会遇到路由选择环路，遭遇无穷计数问题。

**健壮性（LS的健壮性更强）**：在LS中，每个节点都通过接收和处理网络中所有节点的链路状态通告（LSA）来计算其自身的路由表。因此，即使某个节点广播了不正确的链路开销信息，但每个节点独立计算自己的转发表，这为网络的健壮性提供了一定的保障。而在DV算法中，一个节点可向任意或所有目标节点通告其不正确的最低开销路径。例如一个故障路由器错误地向其邻居提供了自己链路代价极低的信息，这将导致其他路由器将大量流量引向该故障路由器。

## 三、因特网中自治系统内部的路由选择

### 1.RIP

**RIP（Routing Information Protocol）** 的中文名是路由信息协议，它是内部网关协议IGP中最先得到广泛使用的协议。

RIP是一种分布式的**基于距离向量的路由选择协议**，RIP以**跳数（hop count）** 作为代价，每经过一个路由器就加一。RIP允许一条路径最多只能包含15个路由器，距离16相当于不可达，每个DV（距离矢量，Distance Vector）通告最多可以包含 25 个目标网络。，因此RIP只适用于小型互联网。

RIP的特点是：

- 仅和相邻路由器交换信息。
- 路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表，内容是“我到本自治系统AS中所有网络的（最短）距离，以及到每隔网络应经过的下一跳路由器”。
- 按照固定的时间间隔交换路由信息，如每隔30秒一次；当网络拓扑发生改变时，路由器也会及时向相邻路由器通告拓扑变化后的路由信息。

> **注意**：到直接连接的网络的距离定义为1，也有些地方定义为0（理由是路由器在和直接连接在该网络上的主机通信时，不需要经过另外的路由器），具体视情况而定，但两种不同的定义都不影响RIP的实现。

RIP以应用进程的方式实现，通告报文通过**UDP**报文传送（很有意思，以应用层的进程的形式借助传输层的UDP实现了网络层的RIP协议）。

### 2.OSPF

**OSPF（Open Shortest Path First）** 的中文名是开放最短路径优先。它同样是内部网关协议IGP中的协议，是为了克服RIP的缺点而开发出来的。

OSPF最主要的特征是使用分布式的**链路状态协议**，而不是向RIP那样的距离向量协议。相较于RIP，OSPF新增了以下“高级特性”（RIP所没有的）：

- 安全，所有的OSPF报文都是经过认证的，可防止恶意攻击。
- 允许有多个代价相同的路径存在，即当OSPF发现到达目的地有多条代价相同的路径时，它可以将这些路径均添加到路由表中（RIP只能保存一个），在它们之间实现某种程度上的负载均衡。
- 对单播和多播路由选择的综合支持。
- 支持在单个自治系统AS中的层次结构，我们在下面详细介绍其在AS中的层次结构。

**层次化的OSPF路由**如下图所示：

<img src="https://bu.dusays.com/2024/11/26/67457d7f57f9e.png" alt="10" style="zoom: 67%;" />

一个OSPF自治系统能够层次化地配置多个区域，包括图中的骨干区域和本地区域，每个区域都运行自己的OSPF链路状态路由算法，区域内的每台路由器的链路状态通告仅在本地区域内广播，且仅拥有本地区域的拓扑信息。

- 区域边界路由器（area border router）负责连接多个区域，并在不同区域之间传播路由信息。
- 骨干路由器（backbone router）仅在骨干区域内，运行OSPF路由。
- 边界路由器（boundary router）用于连接其他的AS。

## 四、ISP之间的路由选择：BGP

### 1.层次路由

所有路由器在一个平面所面临的问题：

- 规模问题：规模巨大的网络中，路由信息的存储、传输和计算代价巨大。
- 管理问题：不同的网络所有者希望按照自己的方式管理网络，但一个平面的路由只能用相同的路由选择算法，且不能隐藏自己的网络细节。

**层次路由**将互联网分成一个个AS（autonomous systems，自治系统），一个AS用AS Number（ASN）唯一标识，一个ISP可能包括一个或多个AS。

通过这种方式，路由变成了两个层次的路由：

AS内部路由：在同一个AS内的路由器运行相同的路由协议，但不同的AS可能运行着不同的内部网关协议，解决了规模和管理问题。

AS外部路由：所有的AS运行相同的AS间路由选择协议，称为**边界网关协议（Border Gateway Protocol，BGP）**，解决AS之间的路由问题，完成AS之间的路由互通。

### 2.BGP

#### （1）简介

边界网关协议BGP采用**路径向量（path vector）路由选择协议**，不同于传统的距离向量，其向其他AS通告的信息不仅包括到达目标的下一跳和代价，还包括到达各个目标的详细路径（AS序号的列表），这一点使得BGP能够避免简单DV算法中的路由环路问题。

BGP协议只是力求寻找一条能够到达目的网络且比较好的路径，而并非要寻找一条最佳路由，因为还要考虑不同的路由选择策略，如国内的站点在传送数据时尽量避开某些对我国安全有威胁的国家等等。

BGP使用**TCP**交换报文，BGP报文有以下四种：

- OPEN（打开）报文：打开TCP连接，认证发送方。
- UPDATE（更新）报文：通告新路径，或者撤销原路径。
- KEEPALIVE（保活）报文：在没有更新时保持连接，也用于对OPEN 请求确认
- NOTIFICATION（通知）报文：报告以前消息的错误，也用来关闭连接

#### （2）通告BGP路由信息

<img src="https://bu.dusays.com/2024/11/26/67457d8ab2a52.png" alt="11" style="zoom:50%;" />

上图是一个具有三个自治系统的简单网络，对于每个AS中的路由器，我们可以分为两类：

- **网关路由器（gateway router）**：位于AS边缘的路由器，直接连接到其他AS中的一台或多台路由器，如图中的1c、2a等。
- **内部路由器（internal router）**：仅连接在它自己AS中的主机和路由器，如图中的1a、1b。

在BGP中，每对路由器通过使用179端口的半永久**TCP连接**交换路由选择信息，每一条这样的直接连接以及通过它发送的所有BGP报文，称为**BGP连接（BGP Connection）**。BGP连接也可分为两种：

- **外部BGP（eBGP）**：跨越两个AS的BCP连接。
- **内部BGP（iBGP）**：在相同AS中的两台路由器之间的BGP连接（iBGP连接用不总是与物理链路对应）。

![12](https://bu.dusays.com/2024/11/26/67457d94e46fc.png)

我们以上图为例考虑实现向所有路由器通告右下角子网x的可达性：

网关路由器3a先向网关路由器2c发送一个eBGPb报文“AS3 x”，表示x存在且位于AS3中。网关路由器2c然后向AS2中的所有其他路由器（包括网关路由器2a）发送iBGP报文“AS3 x”。网关路由器2a接下来向网关路由器1c发送一个eBGP报文“AS2 AS3 x”，报文中包括了AS序号形式的到达x的详细路径。最后网关路由器1c使用iBGP向ASI中的所有路由器发送报文“AS2 AS3 x”。在这个过程完成后，AS1和AS2的每个路由器都知道了x的存在并且也都知道了通往x的AS路径。

#### （3）BGP路径选择

当GP 路由器通过 BGP 连接通告前缀（这里前缀代表目的子网，例如我们上面提到的x）时，它不仅仅通告 IP 前缀，还会包含一些重要的**BGP属性（BGP Attributes）**，其中两个最重要的属性是 **AS-PATH** 和 **NEXT-PATH** 。

**AS-PATH** 属性包含了该通告已经通过的AS列表，例如下图中，AS1到子网x有两条路，一条使用AS-PATH“AS2 AS3”，而另一条使用AS-PATH“AS3”。该属性还可以用来检测和防止通告环路，如果一台路由器在路径列表中看到了包含自己的AS，它将拒绝通告。

**NEXT-PATH** 是**AS-PATH** 起始的路由器接口的IP地址，例如下图中的2a和3d分别是从AS1到x的两条路径的NEXT-PATH。

<img src="https://bu.dusays.com/2024/11/26/67457d9da9bb4.png" alt="13" style="zoom:50%;" />

**热土豆路由选择（hot potato routing）**，选择具备最小内部区域代价的网关作为往X的出口。以上图中的1b为例，如果想到达子网x，它可选的两条路径的NEXT-PATH分别为2a和3d。因为1b到达2a的最短距离为2，到达3d的最短距离为3，因此选择到达NEXT-PATH开销更小的路径“AS2 AS3”。核心思想是尽可能快地将分组送出其AS，就像丢烫手的土豆一样。

在实践中，BGP不仅会使用热土豆路由选择，还会结合其他多种策略和因素来优化路由选择。

## 五、ICMP

### 1.简介

**ICMP**的中文名是**网际控制报文协议（Internet Control Message Protocol）**。

ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP报文封装在IP数据报中，作为其中的数据部分，通常被认为是IP的一部分（但是从体系结构上讲它位于IP之上，因为ICMP报文是作为IP有效载荷承载的，就像TCP与UDP报文段作为IP有效载荷被承载那样，但不论如何，ICMP都是**网络层协议**）。

ICMP报文段种类有两种，即**ICMP差错报告报文** 和**ICMP询问报文**。

ICMP报文的前四个字节是统一的格式，包括三个字段：类型、代码和检验和。接着的4个字节与ICMP的类型有关，最后面是数据字段，其长度取决于ICMP的类型，下面是几种常用的报文类型：

<table border="1">
  <thead>
    <tr>
      <th>ICMP 报文种类</th>
      <th>类型的值</th>
      <th>ICMP 报文的类型</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="vertical-align: middle;" rowspan="4">差错报告报文</td>
      <td>3</td>
      <td>终点不可达</td>
    </tr>
    <tr>
      <td>11</td>
      <td>时间超时</td>
    </tr>
    <tr>
      <td>12</td>
      <td>参数问题</td>
    </tr>
    <tr>
      <td>5</td>
      <td>改变路由 (Redirect)</td>
    </tr>
    <tr>
      <td style="vertical-align: middle;" rowspan="2">询问报文</td>
      <td>8 或 0</td>
      <td>回送 (Echo) 请求或回答</td>
    </tr>
    <tr>
      <td>13 或 14</td>
      <td>时间戳 (Timestamp) 请求或回答</td>
    </tr>
  </tbody>
</table>

### 2.ICMP差错报告报文

ICMP差错报文共有四种：

- **终点不可达**：当路由器或主机不能交付数据报时就向原点发送终点不可达报文。
- **时间超过**：当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向原点发送时间超过报文；当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。
- **参数问题**：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。
- **改变路由（重定向）**：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。

所有的ICMP差错报文中的数字字段都有相同的格式，如下图所示：把需要进行差错报告的IP数据报的首部和数据字段的前8个字节（这8个字节是为了得到传输层TCP/UDP的端口号以及传输层TCP报文的发送序号）提取出来，作为ICMP报文的数据字段，前面在加上相应的ICMP差错报告报文的前8个字节，就构成了ICMP差错报告报文。

<img src="https://bu.dusays.com/2024/11/26/67457da6f0f7c.png" alt="14" style="zoom:67%;" />

在以下情况不应发送ICMP差错报告报文：

- 对ICMP差错报告报文，不再发送ICMP差错报告报文（禁止套娃doge）。
- 对第一个分片的数据报片的所有后续数据报片，都不发送ICMP差错报告报文。
- 对具有多播地址的数据报，都不发送ICMP差错报告报文。
- 对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报，不发送ICMP差错报告报文。

### 3.ICMP询问报文

常用的ICMP询问报文有两种：

- **回送请求和回答**：ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问，收到的主机必须给源主机或路由器发送ICMP回送回答报文。这种报文用于测试目的站是否可达以及了解其有关状态。
- **时间戳请求和回答**：ICMP时间戳请求报文是请某台主机或路由器回答当前的日期和时间。时间戳请求与回答可用于时钟同步和时间测量。
