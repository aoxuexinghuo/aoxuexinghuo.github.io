---
title: 计算机组成原理 第二章 数据的表示和运算
date: 2025-02-25 17:42:45
category: 计算机组成原理
tags:
  - 计算机组成原理
  - 笔记
description: 发明补码的人真是天才！
cover: https://bu.dusays.com/2025/02/25/67bd9167c9ae3.png
---

## 一、进位计数制及其相互转换

### 1.进位计数制

r进制计数法，逢r进一，这里的r为基数。

**基数**：每个数码位所用到的不同符号的个数，r进制的基数为r。

二进制（Binary）数的表示方法：11002B

十进制（Decimalism）数的表示方法：985D

十六进制（Hexadecimal）数的表示方法：9494H 或 0x9494 或 0X9494

> **计算机系统内部采用二进制的原因**
>
> 1. 二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本比较低。
> 2. 二进制位 1 和 0 正好与逻辑值“真”和“假”相对应，为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件。
> 3. 二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。

### 2.不同进制数之间的相互转换

花里胡哨，实际上熟悉每一位的权重自己拼凑更快。

**二级制数转换为八进制和十六进制数**：以小数点为界，每 3 位（八进制）或 4 位（十六进制）一组，分别用对应的八进制或十六进制数取代。不足的部分，整数部分高位补 0，小数部分低位补 0。

**十进制小数转换为二进制小数**：整数部分使用**除基取余法**，小数部分使用**乘基取整法**。

除基取余法顾名思义，乘基取整法如下图所示：

![2eb05651-e316-442a-a0ec-4a5fed324398](https://bu.dusays.com/2025/02/19/67b594c08cf15.png)

因此 0.3 用二进制表示为 0.01001…B，后面无限循环1001，这里精确到小数点后五位。

> **注意**：在计算机中，小数和整数不一样，整数可以连续表示，但**小数是离散的**，所以并不是每个十进制小数都可以准确地用二进制小数表示，例如这里的 0.3 就无法得到精确的结果。但每一个二进制小数都可以用十进制小数精确表示。

## 二、定点数的编码表示

### 1.真值和机器数

**真值**：生活中，通常用正负号来分别表示整数和负数。+7，-8 这种带正负号的数称为真值。真值是机器数所代表的实际值。

**机器数**：计算机中，通常把数据的符号和数字部分一起编码，将符号数字化，通常用 0 表示正，用 1 表示负。这种把符号数字化的数称为机器数。

### 2.定点数和浮点数

根据小数点的位置是否固定，在计算机中有两种数据格式：**定点表示**和**浮点表示**

**定点数**：小数点的位数固定，如 996.007（常规计数）

**浮点数**：小数点的位置不固定，如9.96007*10^2（科学计数法）

**定点数**又分为**无符号数**和**有符号数**，**有符号数**又可以用**原码、反码、补码、移码**四种方式表示。

现代计算机中，通常用**补码整数表示整数，用原码小数浮点数的尾数部分，用移码表示浮点数的阶码部分**。

### 3.机器数的定点表示

#### （1）无符号数的表示

**无符号数**：所有的二进制位数均为数值位，没有符号位

n 位 r 进制数可表示 r^n 个无符号数，范围为 0 到 r^n-1。

通常无符号数只有整数，不存在无符号小数（例如 C 语言中 unsigned 只能用来修饰整数相关的关键字，不能修饰 float）。

#### （2）有符号数的定点表示

定点表示法用来表示定点小数和定点整数：

- **定点小数**是纯小数，约定小数点在符号位之后。
- **定点整数**是纯整数，约定小数点位置在有效数值部分最低位之后。

![dd788e55-6b81-4843-9d8e-e5c5d99cace5](https://bu.dusays.com/2025/02/19/67b5a23490baf.png)

> **注意**：机器内部实际上并无小数点，只是人为约定。此外，可以用原码、反码补码表示定点整数和定点小数，用移码表示定点整数。

对于定点整数我们常用**逗号**区分符号位和有效数值部分：

![image-20250219185916462](https://bu.dusays.com/2025/02/19/67b5cef768694.png)

对于定点整数我们常用**点号**区分符号位和小数部分：

![image-20250219185858558](https://bu.dusays.com/2025/02/19/67b5cefb3458d.png)



因此这里的 1.11 的真值实际上并不是 1 点 11，而是**负 0 点 11**。

#### （3）原码

**原码**：用机器的最高位表示数的符号，其余各位表示数的绝对值。实际上我们上面两张图片里的就是使用的原码表示法。

原码整数和小数的表示范围如下图所示：

![image-20250219185503036](https://bu.dusays.com/2025/02/19/67b5cefeec82e.png)

![image-20250219185430814](https://bu.dusays.com/2025/02/19/67b5cf02264c1.png)

|                      优点                      |                  缺点                  |
| :--------------------------------------------: | :------------------------------------: |
| 与真值的对应关系简单、直观，与真值的转化简单。 | 0 的表示不唯一，有 +0 和 -0 两个编码。 |
|        用原码实现**乘除运算**比较简单。        |    用原码实现**加减运算**比较复杂。    |

#### （4）反码

**反码**：在原码的基础上，**若符号位为0，则反码与原码相同**；**若符号位为1；则数值位全部取反**。

因此反码与原码所能表示的范围相同，且也存在 +0 和 -0两种表示形式。

在计算机中，反码是原码转换到补码的中间形式，很少拿来使用。

#### （5）补码

**补码**：**正数的补码 = 原码**；**负数的补码 = 反码末位 + 1**（要考虑进位）

**0** 的补码是**唯一**的，因此补码可以比原码多表示一个数字。

![image-20250219200042362](https://bu.dusays.com/2025/02/19/67b5cf05a53f7.png)

**补码的作用**：使用补码可以将减法操作转变为等价的加法，ALU中无需集成减法器，执行加法操作时，符号位一起参与运算。

**由 [x]补 快速求 [-x]补 的技巧**：符号位、数值位全部取反，末位 +1。

**负数的原码补码转换技巧**：最右边的 1 及其右边部分保持不变，剩下的数值位全部取反。

说到补码就不得不拿出 CSAPP 上的这张图了，设计这个图的人简直就是天才：

![d1649d4b-0d28-45a1-a141-c789d2ceddac](https://bu.dusays.com/2025/02/19/67b5cf0a40739.png)

#### （6）移码

**移码**：在补码的基础上将符号位取反。

因此移码和补码的表示范围相同，且 0 也只有一种表示形式。

> **注意**：移码常用来表示浮点数的阶码，它只能表示整数，不能表示小数

**优点**：便于计算机比较大小，如下图所示。

![187a92a3-d0ec-4ce6-9a72-791b0e283b85](https://bu.dusays.com/2025/02/19/67b5cf0fda3bf.png)

**移码的定义**：移码 = 真值 + **偏置值**

例如八位数的移码偏置值为 2^7 = 128B = 1000 0000B，即2^(n-1)。

若真值为 -127，则移码为 -127 +128 = -11111111 + 10000000 = 0000 0001

#### （7）四种编码总结

![caab6a19-9055-44b7-b75f-0a2a01786c53](https://bu.dusays.com/2025/02/19/67b5cf14c73fc.png)

符号位为 0 时，原码等于反码等于补码；符号位为 1 时，原码和补码之间相互转换的方式相同，均为数值位按位取反再加一。

### 4.神奇的补码

**补码的作用**：使用补码可以将减法操作转变为等价的加法，ALU中无需集成减法器，执行加法操作时，符号位一起参与运算。

为什么补码能够实现这样的功能呢？

以 4 位的补码为例，因为只能存储 4 位数字，所以它本质上相当于对数字进行取模运算，模为 2 的 4 次方，即为 16。而后将得到的余数存储下来（这里需要了解负数的取模运算规则，例如 -5 对 16 取模，得到的余数为11）。

对于真值 b，我们定义 b 的补数为 模 + b = b的补数。实际上，这里 b 的补数就是补码。

可以看到，当 b 为正值时，直接溢出，进行取模运算；当b为负值时，补数相当于 模 - |b|。

对于 b < 0，如果我们想要运算 a + b，只需要计算 a + b的补数 即可。因为代入我们上面对补数的定义可以得到下面的公式：

a + b的补数 = a + 模 + b = a + b，因为计算机会自动抛弃溢出的位数（假设 0 < a + b < 模）。

举个栗子，a 取 5，b 取 -3 ，-3 的补数为 模 + （-3） = 16 +（-3）= 13 = 1101。

可以看到 1101实际上就是我们定义的 -3 的补码。

那么，5 +（-3） =  0101 + 1101 = 10010，计算机自动保留四位，得到结果为 0010，即为 2。

此外，从这个公式我们也能看出为什么负数补码和原码的转换方式是数字位取反再加一：

同样以 4 位补码为例，b 的补数 - b = 模 = 16 = 1111 +1，那么 b 的补数 + （|b| -1） = 1111

-3 的补数 1101 和什么样的数相加才能得到 1111呢？答案是，0010。

所以 |b| - 1 = 0010，|b| = 0010 + 1 = 0011，那 b 的原码不就是 1011吗？ 

反过来原码转换成补码我们可以用（b 的补数 - 1）+ |b| = 1111，只需要改变一下 -1的位置就行了。

感觉写的有点乱啊，拼尽全力只能这样了。

### 5.C语言强制类型转换

C语言中的有符号数以补码的形式存储，chart型默认按照无符号数整数解释。

**无符号变有符号**：二进制各个位数的值不变，仅改变解释这些位的方式。

**长整数变短整数**：直接高位截断，简单粗暴。

**短整数变长整数**：无符号数进行零扩展，高位用零填充；有符号数进行符号扩展，高位部分用原数字的符号位填充（0 或 1）。

## 三、基本运算部件

**补充常用逻辑门电路**：

![11610001740206561](https://bu.dusays.com/2025/02/22/67b97262227fb.jpg)

### 1.一位全加器

![0dcd217b-f0ae-464e-bae8-262ff2e7e26f](https://bu.dusays.com/2025/02/21/67b83ad5b546a.png)

**一位全加器（FA，full adder）** 是最基本的加法单元，有加数 A_i、加数 B_i 与低位传来的进位 C_i-1 共三个输入，有本位和 S_i 及向高位的进位 C_i 共两个输出。
$$
和表达式：S_{i}=A_{i}\oplus B_{i}\oplus C_{i-1}
$$

$$
进位表达式：C_{i}=A_{i}B_{i}+(A_{i}\oplus B_{i})C_{i-1}
$$

### 2.串行进位加法器

将 n 个 FA 相连可以得到 n 位加法器，称为串行进位加法器。

![073dd972-e89f-47b2-86b0-c2cb70d4c787](https://bu.dusays.com/2025/02/21/67b83adb98441.png)

在串行进位加法器中，低位运算的产生进位所需的时间将影响高位运算的时间，位数越多，延迟时间就越长。

### 3.并行进位加法器

**并行进位（也称先行进位）加法器**可以加快进位产生的速度，进而提升加法运算产生结果的速度。

从前面的串行进位加法器中我们可以得到：
$$
C_{i}=A_{i}B_{i}+(A_{i}\oplus B_{i})C_{i-1}
$$

$$
C_{i}=A_{i}B_{i}+(A_{i}\oplus B_{i})(A_{i-1}B_{i-1}+(A_{i-1}\oplus B_{i-1})C_{i-2})
$$

$$
……
$$

一直展开到 C_0，我们可以发现，第 i 位向更高位的进位 C_i 其实从一开始就能够根据被加数、加数的第 1 至 i 位，再结合 C_0 得到，而不用等待前一位的进位。

我们可以按照这种思路设计出一个四位并行进位加法器：

![5223241740126021](https://bu.dusays.com/2025/02/21/67b83ae060101.jpg)

![b066ce64-06b8-4d17-84d8-24675dc1ab0f](https://bu.dusays.com/2025/02/21/67b83ae23010b.png)

构造一个 n 位并行进位加法器，需要将 n 个一位全加器连接上 n 位先行进位部分（简称 **CLA 部件**），其作用是“并行产生进位”，即 n 位进位信息几乎是同时产生的。当计算更多位时，我们可以选择将多个 4 并行进位加法器进行串联。

### 4.带标志加法器

在 n 位加法器的基础上还会再增加一些逻辑电路，使其不仅能计算和/差，还能生成相应的标志信息，分别是：

- **OF（Overflow Flag）溢出标志**，用于判断**有符号数**的加减运算是否溢出。0 表示未溢出，1 表示溢出。
- **SF（Sign Flag）符号标志**，用于表示**有符号数**的加减运算结果的正负性。 0 表示正，1 表示负。
- **ZF（Zero Flag）零标志**，用于判断加减运算结果是否为0。1 表示结果为 0，0表示结果非 0。
- **CF（Carry Flag）进位/借位标志**，用于判断**无符号数**的加减运算是否溢出。0 表示未溢出，1表示溢出。

### 5.算术逻辑单元（ALU）

ALU 是运算器的**核心**，加法器是 ALU 的**核心**。

ALU的运算数，运算结果位数与计算机的**机器字长**相同。

**ALU 的功能**包括：

- 算术运算 - 加、减、乘、除 等
- 逻辑运算 - 与、或、非、异或、移位 等
- 其他 - 求补码、直送（即不做任何操作）等

![ebd9cda4-2746-4473-8f02-6769c58541af](https://bu.dusays.com/2025/02/22/67b9733218b26.png)

ALU 的基本结构如上图，op 信号用来控制 ALU 所执行的功能，其位数决定了操作数的种类。例如，位数为 3 时，ALU 最多只能有 8 种操作。

## 四、定点数的运算

### 1.定点数的移位运算

#### （1）逻辑移位

将操作数视为无符号整数，直接整体左移或右移，空位补 0，简单粗暴。

#### （2）算术移位

![c83588c0-464f-4e38-9946-eaef09977933](https://bu.dusays.com/2025/02/22/67b97fae89efe.png)

算术移位的一个特点是，移位后符号位不会改变（注意说的是符号位不会改变，而不是符号位不会移动）。、

左移可能会溢出，右移可能会丢失精度。

实际上想象成对真值进行乘 2 ，除 2 运算，自然就知道要补 1 还是 0 了。

#### （3）循环移位

循环移位即为将移出的那一位再填补到另一侧的空位上去。

对于一些有进位位的情况，将进位位视为普通的比特位即可，例如

**1** 01110101，这里标粗的位置是进位位，循环左移结果为 **0** 11101011。

### 2.定点数的加减运算

#### （1）补码加减运算

$$
[A+B]_补=[A]_补+[B]_补(mod2^{n+1})
$$

$$
[A-B]_补=[A]_补+[-B]_补(mod2^{n+1})
$$

#### （2）溢出判断方法

只有以下两种情况才会导致溢出：

**正 + 正 = 负（上溢）；负 + 负 = 正（下溢）**

**方法一**：根据操作数和结果的符号判断
$$
V=A_SB_S\overline C_S+\overline A_S\overline B_SC_S
$$
若 V = 0，则未溢出；若 V = 1，则发生溢出。

**方法二**：根据进位判断

若符号位的进位 Cs 与最高数值位的进位 C1 不同，则发生溢出，相同则没有溢出。
$$
V=C_S\oplus C_1
$$
若 V = 0，则未溢出；若 V = 1，则发生溢出。

**方法三**：双符号位判断

双符号位补码又称模 4 补码，单符号位补码又称模 2 补码。

运算结果的两个符号位 Ss1 和 Ss2 相同，则未溢出，不同则发生溢出，此时最高位符号位代表真正的符号（实际上原理与方法二相同）。
$$
V=S_{S1}\oplus S_{S2}
$$
若 V = 0，则未溢出；若 V = 1，则发生溢出。

> **注意**：对于双符号位补码，实际存储时只存一个符号位，运算时会复制一个符号位，因此不会增加存储所需要的空间。

#### （3）无符号数加减运算

**加法**：直接按位相加，同补码

**减法**：减数**全部位**按位取反，末尾加一，减法变加法。

> **注意**：本质上和补码的加减运算是一样的，因为减数的全部位按位取反再加一后，得到的结果就是减数的相反数的补码。而对于正数来说，原码和补码是相同的，所以依旧可以将其视为补码的加减运算。

**溢出判断**：n bit 无符号整数运算结果是否落在 0 到 2^n - 1 范围内

- **加法**：最高位产生的进位 = 1 时，发生溢出，否则未溢出。
- **减法**：减法变加法，最高位产生的进位 = 0 时，发生溢出，否则未溢出（因为最高位进行的运算是 0 + 1，如果没有进位，说明结果的符号位是 1，为负数，不在表示范围内）。

#### （4）补码加减运算电路

![d2f3e52b-ccb1-4fdb-8cbf-a724a776b0ca](https://bu.dusays.com/2025/02/23/67bac685bd020.png)

补码加减运算电路如上图所示，**Sub（Subtraction）** 信号用于控制电路进行加法还是减法运算，0 表示加法，1 表示减法。当进行加法运算时，加数 B 不会被进行任何处理；进行减法运算时，B 先被按位全部取反，同时，Sub 信号还与 Cin 相连，相当于还会再进行一次加一的操作。

因为无符号数加减运算本质上和补码相同，因此该电路同样也能用于无符号数加减运算。

下图为四种标志信息的逻辑电路：

![261d8c29-29a7-4bd4-bca7-c851bad99162](https://bu.dusays.com/2025/02/23/67badc86091e0.png)
$$
\color{black}OF=C_n\oplus C_{n-1}--即最高位的进位\oplus 次高位的进位，反映\color{red}带符号数\color{black}加减运算是否溢出
$$

$$
\color{black}SF=S_n--也就是运算结果的最高位（符号位），反映\color{red}带符号数\color{black}加减运算的正负性
$$

$$
\color{black}ZF=S_n+…+S_2+S_1--仅当运算结果所有bit全0时，ZF才为1，此时表示运算结果为0
$$

$$
\color{black}CF=C_{out}\oplus C_{in}=C_n\oplus C_0=C_{out}\oplus Sub0--反映\color{blue}无符号数\color{black}加减运算是否溢出
$$

### 3.定点数的乘除运算

本节中，n 均指数值位的位数。

#### （1）原码的乘法运算

原码乘法的特点是：乘积的符号位由两个乘数的符号位异或得到；乘积的数值位是两个乘数的绝对值之积。

**原码一位乘**

![75ef8e87-2a82-487c-b6f3-1cafcbe722fd](https://bu.dusays.com/2025/02/25/67bd9371501b3.png)

在进行运算时，需要先清空 ACC 寄存器，此时 MQ 寄存器中存储的是乘数。

![05126962-9f44-4257-9ab2-be8b4ade0fc4](https://bu.dusays.com/2025/02/25/67bd937873a5f.png)

第一步，MQ 寄存器中的最低位与 X 寄存器中的被乘数相乘，结果加到 ACC 寄存器中。

![470f6e05-d354-44ca-930a-4f308f759753](https://bu.dusays.com/2025/02/25/67bd937e7f131.png)

第二步，将 ACC 寄存器和 MQ 寄存器中的数视为一个整体，进行**逻辑右移**。

就这样每次都**先进行加法，然后再进行移位，重复 n 次**，n 为数值位的长度，最后得到结果，乘积的高位存储在 ACC 中，低位存储在 MQ 中。

**乘法两位乘**（王道上没有？到时候看情况补吧。）

#### （2）补码的乘法运算

需要知道所以然吗？

**补码一位乘（booth算法）**

补码一位乘的规则是**进行 n 轮加法、移位（注意是算术右移），最后再多来一次加法**。

根据辅助位（初始为 0）和 MQ 最低位来决定加数的内容：

- 辅助位 - MQ 最低位 = 1 时，（ACC）+ [x]补

- 辅助位 - MQ 最低位 = 0 时，（ACC）+ 0

- 辅助位 - MQ 最低位 = -1 时，（ACC）+ [-x]补


![c49cf462-c4e6-4a20-8cc2-6630abbcbc6a](https://bu.dusays.com/2025/02/26/67bec1823efa7.png)

**注意**：图中红色比特位我们称之为辅助位，虽然他也在 MQ 寄存器，但为了统一，我们依旧将灰色比特位称为 MQ 最低位，在进行算术右移时，ACC 和 MQ（包括辅助位）的内容看做一个整体进行右移。

**补码两位乘**（待定）

#### （3 ）快速乘法器

……

#### （4）原码的除法运算

原码除法的特点是：商的符号位由被除数和除数的符号位异或得到；商的数值位是这两个数的绝对值之商。

**恢复余数法**

![739ebca0-f135-4f53-864b-78fb087f7dcb](https://bu.dusays.com/2025/02/26/67bf0f15f0f1f.png)

初始情况下如上图所示，MQ 寄存器清零，从末位开始上商。

但计算机不会直接判断商 1 还是商 0，而是选择先默认商1，然后求余数（ACC）-（除数）-> ACC。

以改图为例就是计算出 01101 的负数的补码为 10011，然后将其与（ACC）相加，得到结果为 11110，首位为 1，说明是负数，不应该商 1。

于是计算机将商上去的 1 改为 0，再恢复余数（ACC）-（除数）-> ACC。

（什么？你问我为什么原码除法里涉及了补码？计算机：什么原码补码，我不到啊，我只会算二进制加法。）

如果求出的余数是正数，则说明商 1 是正确的，不需要修改。

确定了商之后，将 ACC 和 MQ 的内容视作整体进行左移，然后继续在 MQ 的末尾上商。

以此类推，共计**上商 n+1 次，逻辑左移 n 次**。

> **注意**：如果最后一步上商后余数为负，依旧需要恢复余数并改商 0 。

![image-20250226154629734](https://bu.dusays.com/2025/02/26/67becc6e8c644.png)

最后结果如上图所示，求得商为 0.1101，余数为 0.0111*2^(-n)，因为共左移 n 次。

**不恢复余数法（加减交替法）**

![ea17cce7-917f-4888-8747-e734ae136c7d](https://bu.dusays.com/2025/02/26/67bf0dfd705c4.png)

回顾恢复余数法的过程，在发现余数 a 为负后，选择进行加 b 左移再减 b，最后得到新的余数。我们可以将这三步合并为两步，直接进行左移然后加 b，这就是不恢复余数法（也称加减交替法）。

- 恢复余数法：当余数为负时商 0，并 + |除数|，再左移，再 - |除数|（三步）
- 加减交替法：当余数为负时商 0，并左移，再 + |除数|（两步）

![image-20250226161006092](https://bu.dusays.com/2025/02/26/67bf0e0239b14.png)

> **注意**：虽然这种方式叫不恢复余数法，但如果最后得到的余数为负，依旧要改商 0，并加上 [|y|] 补得到正确的余数。也就是说依旧有可能会出现恢复余数的步骤。

#### （5）补码的除法运算

补码除法的特点：符号位参与运算，被除数（余数）、除数均采用**双符号位**。

具体计算流程为：

- 被除数和除数同号，则被除数减去除数；异号则被除数加上除数。
- 余数和除数同号，商 1，余数左移一位减去除数。
- 余数和除数异号，商 0，余数左移一位加上除数。
- 重复进行 n 次。
- 末尾商恒置为 1（省事且精度误差不超过 2^(-n)）。

![image-20250226170134869](https://bu.dusays.com/2025/02/26/67bf0e07747f2.png)

> **注意**：因为补码的加减交替法最后的末位商恒置为1，因此不会出现恢复余数的情况。

**原码、补码加减交替法的比较**

|      除法类型      | 符号位参与运算 |    加减次数    | 移位情况  |   上商、加减原则   |             说明             |
| :----------------: | :------------: | :------------: | :-------: | :----------------: | :--------------------------: |
| **原码加减交替法** |       否       | n + 1 或 n + 2 | 左移 n 次 |     余数的正负     | 若最终余数为负，则需恢复余数 |
| **补码加减交替法** |       是       |     n + 1      | 左移 n 次 | 余数和除数是否同号 |         末位商恒置 1         |

## 五、浮点数的表示与运算

### 1.浮点数的表示

#### （1）浮点数的表示格式

一般浮点数的表示为：

![8458fe9d-ee86-4e56-a50d-ca45da331f22](C:\Users\LENOVO\AppData\Local\Temp\8458fe9d-ee86-4e56-a50d-ca45da331f22.png)

- **阶码**：常用补码或移码表示的定点整数
- **尾数**：常用原码或补码表示的定点小数

$$
浮点数的真值：N=r^E*M（对照十进制的科学记数法）
$$

r 为阶码的底，通常为 2（也可为 4、8 等），E 为阶码，M 为尾数。

#### （2）浮点数的表示范围



#### （3）浮点数的规格化

为了使有效数字尽量占满尾数位数，需要进行规格化操作。对于规格化的浮点数，要求**尾数的最高数值位必须是一个有效值**（对于原码来说 1 为有效值，对于补码来说与符号位相反的数为有效位）。

- **左规**：当运算结果的尾数的最高位不是有效位时，进行左规，尾数每左移一位、阶码减一。左规可能要进行多次。
- **右规**：当运算结果的尾数的有效位进到小数点前面时，进行右规（双符号位为 10 或 01）。尾数右移一位、阶码加一。右规只需进行一次，且右规时可能会导致溢出。

左规的时候会出现溢出吗？下溢算吗？

> **注意**：这里讨论的情况为阶码的基数（底）r 为 2 的情况。当 r 为 4 时，每次尾数每次要移动两位，规格化后要求最高两位不全为无效位。

**规格化**

![f3969cc4-35a3-4cb0-8581-ffb3272c0eff](C:\Users\LENOVO\AppData\Local\Temp\f3969cc4-35a3-4cb0-8581-ffb3272c0eff.png)

规格化浮点数的特点

锐意更新中…

要碎了…

### 2.IEEE 754 标准

阶码、移码各占多少位，各用什么码表示







