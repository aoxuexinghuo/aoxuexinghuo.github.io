---
title: 操作系统 第二章 进程与线程
date: 2025-03-27 15:38:38
category: 操作系统
tags:
  - 操作系统
  - 408
cover: https://bu.dusays.com/2025/03/23/67dffa6e3a768.jpeg
series: OS
---

> **🚥操作系统 系列文章导航🚥**
>
> {% series OS %}

## 一、进程与线程

### 1.进程的概念与特征

- **程序**：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。
- **进程（Process）**：是动态的，是程序的一次执行过程（同一个程序多次执行会对应多个进程）。

> **注意**：一个进程可以执行一个或几个程序，一个程序也可构成多个进程。

相比于程序，进程拥有以下特征：

- **动态性**：进程是程序的一次执行过程，是动态地产生、变化和消亡的。动态性是进程**最基本**的特征。
- **并发性**：内存中有多个进程实体，各进程可并发执行。
- **独立性**：进程是能独立运行、独立获得资源、独立接受调度的基本单位。
- **异步性**：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供 “进程同步机制” 来解决异步问题。
- **结构性**：每个进程都会配置一个 PCB。结构上看，进程由程序段、数据段、PCB 组成。

### 2.进程的组成

进程是一个独立的运行单位，也是操作系统进行**资源分配**和**调度**的**基本单位**。它由进程控制块（PCB）、程序段、数据段三部分组成。其中最核心的部分是 PCB，它是进程实体的一部分，是进程存在的**唯一标志**。

PCB 是给操作系统用的数据结构；程序段、数据段是给进程自己用的，与进程自身的运行逻辑有关。

**（1）进程控制块**

PCB 主要包括以下几部分内容：

- **进程描述信息**：进程被创建时，操作系统会为该进程分配一个唯一的、不重复的 PID；UID 用于标识进程所归属的用户，为共享和保护服务。
- **进程控制和管理信息**
- **资源分配清单**：
- **处理机相关信息**：也称 CPU 上下文，主要指 CPU 中各寄存器的值。用于实现进程切换。

|   进程描述信息    | 进程控制和管理信息 | 资源分配清单 | 处理机相关信息 |
| :---------------: | :----------------: | :----------: | :------------: |
| 进程标识符（PID） |    进程当前状态    |  代码段指针  |  通用寄存器值  |
| 用户标识符（UID） |     进程优先级     |  数据段指针  |  地址寄存器值  |
|                   |  代码运行入口地址  |  堆栈段指针  |  控制寄存器值  |
|                   |   程序的外存地址   |  文件描述符  |  标志寄存器值  |
|                   |    进入内存时间    |     键盘     |     状态字     |
|                   |    CPU 占用时间    |     鼠标     |                |
|                   |     信号量使用     |              |                |

**（2）程序段**：能够被进程调度程序调度到 CPU 执行的程序代码段。

**（3）数据段**：一个进程的数据段，可以是进程对应的程序加工处理原始数据，也可以是程序执行时产生的中间或最终结果。

### 3.进程的状态与转换

通常进程有以下 5 种状态，前 3 种是进程的基本状态：

- **运行态**：进程正在 CPU 上运行。在单 CPU 中，每个时刻只有一个进程处于运行态。
- **就绪态**：进程获得了除 CPU 外的一切所需资源，一旦得到 CPU，便可立即运行。系统中处于就绪态的进程可能有多个，通常将它们排成一个队列，称为**就绪队列**。
- **阻塞态**：也称**等待态**。进程正在等待某一事件而暂停运行。系统通常将处于阻塞态的进程也排成一个队列，甚至根据阻塞原因的不同，设置多个**阻塞队列**。
- **创建态**：进程正在被创建，尚未转到就绪态。
- **终止态**：进程需要结束运行时，系统首先将该进程设置为终止态。然后进一步处理资源释放和回收等工作。

**进程状态的转换**：

![image-20250327205036150](https://bu.dusays.com/2025/03/27/67e549dc454bf.png)

在一个系统中，通常存在着许多进程的 PCB，有的处于就绪态，有的处于阻塞态，而且阻塞的原因各不相同。为了方便进程的调度和管理，需要将各个进程的 PCB 用适当的方法组织起来。目前，常用的组织方式有**链接方式**和**索引方式**两种。

**链接方式**：将同一状态的 PCB 链接成一个队列，不同状态对应不同的队列，也可将处于阻塞态的进程的 PCB，根据其阻塞原因的不同，排成多个阻塞队列。

<img src="https://bu.dusays.com/2025/03/27/67e54e288413a.png" alt="image-20250327210511610" style="zoom: 50%;" />

**索引方式**：将同一状态的进程组织在一个索引表中，索引表的表项指向相应的 PCB，不同状态对应不同的索引表。

<img src="https://bu.dusays.com/2025/03/27/67e54e2bc6017.png" alt="image-20250327210604082" style="zoom: 50%;" />

### 4.进程控制

**进程控制**的主要功能是对系统中的进程实施有效的管理，具有创建新进程、撤销已有进程、实现进程状态转换等功能。

在操作系统中，一般将进程控制用的程序段称为**原语**，原语可以用**关中断指令**和**开中断指令**这两个**特权指令**实现原子性。

#### （1）进程的创建

允许一个进程创建另一个进程，此时创建者为**父进程**，被创建的进程称为**子进程**。子进程可以继承父进程所拥有的资源。当子进程终止时，应将其从父进程那里获得的资源还给父进程。

引起进程创建的事件：

- 终端用户登录系统：分时系统中，用户登录成功，系统会为其建立一个新进程。
- 作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程。
- 系统提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求。
- 用户程序的应用请求：由用户进程主动请求创建一个子进程。

**创建原语**：创建态 -> 就绪态

1. 为新进程分配一个唯一的 PID，并申请一个空白的 PCB（PCB 是有限的）。若 PCB 申请失败，则创建失败。
2. 为新进程分配所需资源。这些资源或从操作系统获得，或仅从其父进程获得。
3. 初始化 PCB。
4. 若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。

#### （2）进程的终止

引起进程终止的事件：

- 正常结束：表示进程的任务已完成并准备退出运行。
- 异常结束：进程在运行时，发生了某种异常时间，使进程无法继续进行。
- 外界干预：指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。

**终止原语**：就绪态/阻塞态/运行态 -> 终止态 -> 无

1. 根据被终止进程的标识符，检索出该进程的 PCB，从中读出该进程的状态。
2. 若被终止进程处于运行状态，立即终止该进程的执行，将 CPU 资源分配给其他进程。
3. 若该进程还有子孙进程，则通常需将其所有子孙进程终止（有些系统无此要求）。
4. 将该进程所拥有的全部资源，或归还给其父进程，或归还给操作系统。
5. 将该 PCB 从所在队列（链表）中删除。

有些系统不允许子进程在父进程终止的情况下存在，对于这类系统，若一个进程终止，则它的所有子进程也终止，这种现象称为**级联终止**。然而不是所有操作系统都是这样设计的。

#### （3）进程的阻塞和唤醒

当进程需要等待系统分配某种资源或等待相互合作的其他进程完成工作，就会从运行态切换到阻塞态；当等待的事件发生，就会再由阻塞态切换到运行态。因何事阻塞，就应由何事唤醒，阻塞原语和唤醒原语必须成对使用。

**阻塞原语**：运行态 -> 阻塞态

1. 找到将要被阻塞进程的标识号（PID）对应的 PCB。
2. 若该进程为运行态，则保护其现场，将其状态转换为阻塞态，停止运行。
3. 将该 PCB 插入相应事件的等待队列，将 CPU 资源调度给其他就绪进程。

**唤醒原语**：阻塞态 -> 运行态

1. 在该事件的等待队列中找到相应进程的 PCB。
2. 将其从等待队列中移出，并置其状态为就绪态。
3. 将该 PCB 插入就绪队列，等待调度程序调度。

#### （4）进程的切换

引起进程切换的事件：

- 当前进程时间片到
- 有更高优先级的进程到达
- 当前进程主动阻塞
- 当前进程终止

**切换原语**：

1. 将运行环境信息存入 PCB
2. PCB 移入相应队列
3. 选择另一个进程执行，并更新其 PCB
4. 根据 PCB 恢复新进程所需的运行环境

### 5.进程通信

**进程间通信（Inter-Process Communication，IPC）** 是指两个进程间产生数据交互。

IPC 需要操作系统支持的原因：进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立，为了保证安全，一个进程不能直接访问另一个进程的地址空间。

PV 操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方式主要有以下三类。

#### （1）共享存储

在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行读/写操作实现进程之间的信息交换。在对共享空间进行读写操作时，需要使用**同步互斥工具**（如 P 操作、V 操作）对共享空间的读/写进行控制。

共享存储又分为两种：**低级方式**的共享是**基于数据结构**的共享；**高级方式**的共享是**基于存储区**的共享。

**操作系统**只负责为通信进程提供**可共享使用的存储空间**和**同步互斥工具**，而数据交换则由用户自己安排读/写指令完成。

#### （2）消息传递

进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的**发送消息**和**接收消息**两个原语进行数据交换。 

消息传递方式是当前应用最广泛的进程间通信机制。在微内核操作系统中，微内核与服务器之间的通信就采用了消息传递机制。

消息传递方式可以分为两种：

- **直接通信方式**：发送进程直接将消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息队列中取得消息。
- **间接通信方式**：发送进程将消息发送到某个中间实体，接收进程从中间实体取得消息。这种中间实体一般称为**信箱**，因此这种通信方式又称**信箱通信方式**。

#### （3）管道通信

**管道**是一个特殊的共享文件，又名 pipe 文件，其实就是在内存中开辟一个大小固定的内存缓冲区。数据在管道中是**先进先出**的（循环队列）。

![image-20250328150645652](https://bu.dusays.com/2025/03/28/67e64f1060d5e.png)

- 管道只能采用**半双工通信**，某一个时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。
- 各进程要互斥地**访问**管道（由操作系统实现）。
- 当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程。
- 当管道读空时，读进程将被阻塞，直到写进程往管道中写入数据，即可唤醒读进程。
- 管道中的数据一旦被读出，就彻底消失，是**一次性操作**。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：①一个管道允许**多个写进程，一个读进程**（2014 年 408 真题高教社官方答案）；②允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据（Linux 的方案）。

> **注意**：写进程往管道写数据，即便管道没被写满，只有管道没空，读进程就可以从管道读数据；读进程从管道读数据，即便管道没被读空，只要管道没满，写进程就可以往管道写数据。

> **疑惑**：王道书上有一句话是 “**管道只能由创建进程所访问**，当父进程创建一个管道后，管道是一种特殊的文件，子进程会继承父进程的打开文件，因此子进程也会继承父进程的管道，并可用它来与父进程进行通信”。个人感觉很奇怪，没有看明白这里的 “管道只能由创建进程所访问” 是什么意思。Deepseek 给出的答案是：在默认情况下，匿名管道的文件描述符仅由创建它的进程及其子进程持有，其他无关进程无法直接访问。因为匿名管道没有文件系统中的路径名，无法被其他无关进程直接打开或访问。若需要跨无关进程通信，应使用命名管道（FIFO）或消息队列等其他 IPC 机制。

#### （4）信号

### 6.线程的概念与特点

引入**进程**的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量；而引入**线程**的目的则是减小程序在并发执行时所付出的时空开销，提供操作系统的并发性能。

线程最直接的理解就是**轻量级进程**，它是一个**基本的 CPU 执行单元**，也是**程序执行流的最小单位**。

线程由线程 ID、程序计数器、寄存器集合和堆栈组成。每个线程都有一个唯一的表示符和一个**线程控制块（TCB）**，TCB 记录线程执行的寄存器和栈等现场状态。

 一个线程可以创建和撤销另一个线程。线程也有就绪、阻塞和运行三种基本状态。

引入线程后，**进程**是**资源分配**的基本单位，**线程**是**调度**的基本单位。

**线程和进程的比较**：

- **调度**：线程切换的代价远低于进程。同一进程中，线程的切换不会引起进程切换。但从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
- **并发性**：引入线程的操作系统中，不仅进程之间可以并发执行，一个进程中的多个线程之间也可并发执行，甚至不同进程中的线程也能并发执行，从而使操作系统具有更好的并发性，提高了系统资源的利用率和系统吞吐量。
- **拥有资源**：线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可以与同属于一个进程的其他线程共享进程所拥有的全部资源。
- **独立性**：某个进程的线程对其他进程不可见。
- **系统开销**：①创建或撤销进程时，系统都要为之分配或回收进程控制块（PCB）及其他资源，所付出的开销远大于创建或撤销进程；②进程切换时设计上下文的切换，而线程切换时只需保护和设置少量寄存器内存，开销很小；③同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信非常容易实现，甚至无需操作系统的干预。
- **支持多处理器系统**：对于传统单线程进程，不管有多少 CPU，进程只能运行在一个 CPU 上，对于多线程进程，可将进程中的多个线程分配到多个 CPU 上执行。

### 7.线程的实现方式

线程的实现可以分为两类：**用户级线程（User-Level Thread，ULT）** 和**内核级线程（Kernel-level Thread，KLT）**。内核级线程也称**内核支持的线程**。

**（1）用户级线程**：在用户级线程中，有关**线程管理（创建、撤销和切换等）** 的所有工作都由**应用程序**在**用户空间**内（用户态）完成，无需操作系统干预，内核意识不到线程的存在。应用程序可以通过使用**线程库**设计成多线程程序。

<img src="https://bu.dusays.com/2025/03/29/67e7cd01251be.png" alt="image-20250329142711599" style="zoom: 67%;" />

- **优点**：①线程切换不需要转换到内核空间，节省了模式切换的开销。②调度算法可以是进程专用的，不同的进程可根据自身的需要，对自己的线程选择不同的调度算法。③用户级线程的实现与操作系统平台无关，对线程管理的代码是属于用户程序的一部分。
- **缺点**：①系统调用的阻塞问题，当线程执行一个系统调用时，不仅该线程被阻塞，进程内的所有线程也都被阻塞。②不能发挥多 CPU 的优势，内核每次分配给一个进程的仅有一个 CPU，因此进程中仅有一个线程能执行。

**（2）内核级线程**：内核级线程的管理工作由**操作系统内核**完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在**核心态**下才能完成。操作系统会为每个内核级线程建立相应的 TCB（线程控制块），通过 TCB 对线程进行管理。

<img src="https://bu.dusays.com/2025/03/29/67e7ccff9ea5e.png" alt="image-20250329142747570" style="zoom:67%;" />

- **优点**：①能发挥多 CPU 的优势，内核能同时调度同一进程中的多个线程并行执行。②若进程中的一个线程被阻塞，则内核可以调度该进程中的其他线程占用 CPU，也可运行其他进程中的线程。③内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。④内核本身也可采用多线程技术，可以提高系统的执行速度和效率。
- **缺点**：同一进程中的线程切换，需要从用户态切换到内核态进行，系统开销较大。

**（3）组合方式**：组合实现方式中，内核支持多个内核级线程的建立、调度和管理，同时允许用户程序建立、调度和管理用户级线程。

> **注意**：用户级线程是 “代码逻辑” 的载体，内核级线程是 “运行机会” 的载体。**内核级线程才是处理机分配的单位**。

**线程库（thread library）** 是为程序员提供创建和管理线程的 API，实现线程库的方式有两种：

- 用户级线程库：在用户空间中提供一个没有内核支持的库。库的所有代码和数据结构都位于**用户空间**，调用库中的一个函数只导致用户空间中的一个本地函数的调用。
- 内核级线程库：实现由操作系统直接支持的内核级的一个库。库内的代码和数据结构位于**内核空间**，调用库中的一个 API 函数通常会导致对内核的**系统调用**。

### 8.多线程模型

在同时支持用户级线程和内核级线程的系统中，用户级线程和内核级线程连接方式的不同，形成了三种不同的多线程模型：

<img src="https://bu.dusays.com/2025/03/29/67e7ccfc209cc.png" alt="image-20250329161519414" style="zoom:80%;" />

**多对一模型**：多个用户级线程映射到一个内核级线程（相当于前面的用户级线程模型）。

- **优点**：线程管理是在用户空间上进行的，无须切换到内核态，因此效率较高。
- **缺点**：若一个线程在访问内核时发生了阻塞，则整个进程都会被阻塞；在任何时刻，只有一个线程能够访问内核，多个线程不能同时在多个 CPU 上运行。

**一对一模型**：将每个用户级线程映射到一个内核级线程。

- **优点**：当一个进程被阻塞后，允许调度另一个线程运行，所以并发能力较强。
- **缺点**：每创建一个用户线程，相应地就需要创建一个内核线程，开销较大。

**多对多模型**：将 n 个用户级线程映射到 m 个内核级线程，要求 n 大于等于 m。

- **特点**：既克服了多对一模型并发度不高的缺点，又克服了一对一模型开销太大的缺点。此外，还拥有上述两种模型各自的优点。

### 9.线程的状态与转换

和进程一样，线程之间也存在共享资源和相互合作的制约关系，致使线程在运行时也具有间断性。相应地，线程在运行时也具有下面三种基本状态：

- **执行态**：线程已获得 CPU 而正在运行。
- **就绪态**：线程已具备各种执行条件，只需再获得 CPU 即可立即执行。
- **阻塞态**：线程在执行中因某件事受阻而处于暂停状态。

<img src="https://bu.dusays.com/2025/03/29/67e7cd374e3e0.png" alt="image-20250329183630132" style="zoom: 50%;" />

### 10.线程的组织与控制

线程控制块（TCB）通常包括：

- **线程标识符**
- **一组寄存器**，包括程序计数器、状态寄存器、和通用寄存器
- **线程运行状态**，用于描述线程正处于何种状态
- **优先级**
- **线程专有存储区**，线程切换时用于保存现场
- **堆栈指针**，用于过程调用时保存局部变量即返回地址等。

同一进程中所有的线程都能访问进程的地址空间和全局变量。但是，每个线程都拥有自己的堆栈，且互不共享。

**线程的创建**：用户程序启动时，通常仅有一个称为**初始化线程**的线程正在执行，其主要功能是用于创建新线程。创建新线程时，需要利用一个线程创建函数，并提供相应参数。创建完成后，函数会返回一个线程标识符。

**线程的终止**：

通常，线程被终止后并不立即释放它所占用的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时的资源才能被其他线程利用。

被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行。

有些线程（主要是系统线程）一旦被建立，便一直运行而不会被终止。



