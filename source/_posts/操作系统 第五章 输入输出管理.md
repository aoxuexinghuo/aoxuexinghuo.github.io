---
title: 操作系统 第五章 输入输出管理
date: 2025-04-18 15:43:19
category: 操作系统
tags:
  - 操作系统
  - 408
cover: https://bu.dusays.com/2025/04/18/680202743e409.jpg
series: OS
---

> **🚥操作系统 系列文章导航🚥**
>
> {% series OS %}

## 一、I/O 设备

### 1.设备的分类

**I/O 设备** 是指可以将数据输入计算机的外部设备，或者可以接收计算机输出数据的外部设备。

Unix 系统将**外部设备抽象为一种特殊的文件**，用户可以使用与文件操作相同的方式对外部设备进行操作。

按设备的**使用特性**分类：

- **人机交互类外部设备**：用于用户和计算机之间交互信息的设备，如鼠标、键盘、打印机等。数据传输速度**慢**。
- **存储设备**：用于存储信息的设备，如磁盘、磁带、光盘等。数据传输速度快。
- **网络通信设备**：用于计算机和计算机之间的通信，如网卡、调制解调器。数据传输速度介于上述**两者之间**。

按设备的**传输速率**分类：

- **低速设备**：传输速率仅为每秒几字节到数百字节，如键盘、鼠标等。
- **中速设备**：传输速率为每秒数千字节至数万字节，如激光打印机等。
- **高速设备**：传输速率在数百千字节至千兆字节，如磁盘、光盘。

按**信息交换的单位**分类：

- **块设备**：信息交换以**块**为单位，如磁盘、磁带等。传输速率较**高**，**可寻址**，即对它可随机地读/写任一块。
- **字符设备**：信息交换以**字符**为单位，如鼠标、键盘等。传输速率较**慢**，**不可寻址**，在输入/输出时常采用**中断驱动**方式。

按设备的**共享属性**分类：

- **独占设备**：同一时刻只能由一个进程占用的设备。一旦将这类设备分配给某进程，便由该进程独占，直至用完释放。低速设备一般是独占设备，如打印机。
- **共享设备**：同一时间段内允许多个进程同时访问的设备。对于共享设备，可同时分配给多个进程，通过分时的方式共享使用。典型的共享设备是磁盘。
- **虚拟设备**：通过 SPOOLing 技术将独占设备改造为共享设备，将一个物理设备变为多个逻辑设备，从而可将设备同时分给多个进程。

### 2.I/O 接口

CPU 无法直接控制 I/O 设备的**机械部件**，因此 I/O 设备还要有一个**电子部件**作为 CPU 和 I/O 设备之间的桥梁，用于实现 CPU 对设备的控制。这个电子部件就是 **I/O 接口**，也称**设备控制器**。

I/O 接口的**功能**：

- **接收和识别 CPU 发出的命令**：如 CPU 发来的 read/write 命令，I/O 接口中会有相应的**控制寄存器**来存放命令和参数。
- **向 CPU 报告设备的状态**：I/O 接口中会有相应的**状态寄存器**，用于记录 I/O 设备的当前状态。如 1 表示空闲，0 表示忙碌。
- **数据交换**：I/O 接口中会设置相应的**数据寄存器**。输出时，数据寄存器用于暂存 CPU 发来的数据，之后再由控制器传送设备。输入时，数据寄存器用于暂存设备发来的数据，之后 CPU 从数据寄存器中取走数据。
- **地址识别**：类似于内存的地址，为了区分 I/O 接口中的各个寄存器，也需要给各个寄存器设置一个特定的地址。I/O 控制器通过 CPU 提供的地址来判断 CPU 要读/写的是哪个寄存器。
- **数据缓存**
- **差错控制**

I/O 接口的**组成**：

![image-20250419145933387](https://bu.dusays.com/2025/04/20/6804c7977f610.png)

一个 I/O 控制器可能会对应多个设备。

数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制/状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便 CPU 操作。有的计算机会让这些寄存器占用内存的一部分，称为**内存映像 I/O**；另一些计算机则采用 I/O 占用地址，即**寄存器独立编址**。

**内存映像 I/O 和寄存器独立编址**：

![image-20250419150702557](https://bu.dusays.com/2025/04/20/6804c79d11054.png)

## 二、I/O 控制方式

### 1.程序直接控制方式

![image-20250419151918336](https://bu.dusays.com/2025/04/20/6804c7a107fcc.png)

![image-20250419152445998](https://bu.dusays.com/2025/04/20/6804c7a4c8850.png)

输入的数据最终都要放在内存中，因此有 “CPU -> 存储器” 的操作。同理，输出的数据也放在内存中，需要从内存中取出。

### 2.中断驱动方式

引入中断机制。由于 I/O 设备速度很慢，因此在 CPU 发出读/写命令后，可将等待 I/O 的进程阻塞，先切换到别的进程执行。当 I/O 完成后，控制器会向 CPU 发出一个中断信号，CPU 检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，CPU 从 I/O 控制器读一个字的数据传送到 CPU 寄存器，再写入主存。接着，CPU 恢复等待 I/O 的进程（或其他进程）的运行环境，然后继续执行。

![image-20250419154843539](https://bu.dusays.com/2025/04/20/6804c7a8bd6df.png)

### 3.DMA 方式

与中断驱动方式相比，**DMA 方式**（Direct Memory Access，**直接存储器存取**。主要用于块设备的 I/O 控制）有这样几个改进：

- 基本传送单位是数据块，而不再是字（节）。
- 所传送的数据，是从设备直接送入内存的，或者相反，而不再经过 CPU。
- 仅在传送一个或多个数据块的开始和结束时，才需要 CPU 干预。

![image-20250419161228504](https://bu.dusays.com/2025/04/20/6804c7acedc92.png)

DMA 控制器的组成：

![image-20250419163220779](https://bu.dusays.com/2025/04/20/6804c7b022a06.png)

**DR（Data Register，数据寄存器）**：暂存从设备到内存，或从内存到设备的数据。

**MAR（Memory Address Register，内存地址寄存器）**：在输入时，MAR 表示数据应放到内存中的什么位置；输出时 MAR 表示要输出的数据放在内存中的什么位置。

**DC（Data Counter，数据计数器）**：表示剩余要读/写的字节数。

**CR（Command Register，命令/状态寄存器）**：用于存放 CPU 发来的 I/O 命令，或设备的状态信息。

> **注意**：DMA 控制器在读入数据时，也是一个字一个字读入的。

![image-20250419163105939](https://bu.dusays.com/2025/04/20/6804c7b55bb45.png)

## 三、I/O 软件层次结构

![image-20250420143149286](https://bu.dusays.com/2025/04/20/6804c7b847b40.png)

### 1.用户层软件

![image-20250420143722146](https://bu.dusays.com/2025/04/20/6804c7bc2e72c.png)

### 2.设备独立性软件

**设备独立性软件**，又称**设备无关性软件**。与设备的硬件特性无关的功能几乎都在这一层实现。

主要实现的功能：

- **①向上层提供统一的调用接口**：如 read/write 系统调用。
- **②设备的保护**：原理类似与文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样。
- **③差错处理**：设备独立性软件需要对一些设备的错误进行处理。
- **④设备的分配与回收**
- **⑤数据缓冲区管理**：可以通关缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异。

⑥建立逻辑设备名到物理设备名的**映射关系**；根据设备类型选择调用相应的驱动程序。

设备独立性软件需要通过**逻辑设备表（LUT，Logical Unit Table）** 来确定逻辑设备对应的物理设备。并找到对应的**设备驱动程序**。

下图为一个 LUT 示例：

![image-20250420151854420](https://bu.dusays.com/2025/04/20/6804c7c05c5fe.png)

这里逻辑设备名还带有文件路径，是因为操作系统会**把设备当做一种特殊的文件**，因此会有一个存储路径。

操作系统可以采用两种方式管理逻辑设备表（LUT）：

- **方式一**：整个系统只设置一张 LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。
- **方式二**：为每个用户设置一张 LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而 LUT 就存放在用户管理进程的 PCB 中。

> **注意**：这里类似于前面的单级目录和两级目录的区别。

### 3.设备驱动程序

不同的设备需要不同的设备驱动程序。因为不同设备的内部硬件特性不同，这些特性只有厂家才知道，因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序。

**设备驱动程序**向上层用户程序提供一组标准接口，设备具体的差别被驱动程序所封装，用于接收上层软件发来的抽象 I/O 要求，如 read 和 write 命令，转换为具体要求后，发送给设备控制器，控制 I/O 设备工作；它也将设备控制器发来的信号传送给上层软件，从而为 I/O 内核子系统隐藏设备控制器之间的差异（**双向传递信息**）。

> **注意**：驱动程序一般会以一个独立进程的方式存在。

### 4.中断处理程序

当 I/O 任务完成时，I/O 控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序的处理流程如下：

![image-20250420160055813](https://bu.dusays.com/2025/04/20/6804c7c5f3b7d.png)

> **注意**：设备驱动程序和中断处理程序都会与硬件接触，而上层的用户层软件和设备独立性软件不会与硬件接触。

**功能总结**：

![image-20250420160353130](https://bu.dusays.com/2025/04/20/6804c7ce39aaf.png)

## 四、应用程序 I/O 接口

### 1.输入/输出应用程序接口

底层的设备多种多样，用户层的应用程序无法用一个统一的系统调用接口来完成所有类型设备的 I/O。

根据设备类型的不同，可以将这些接口分为：**字符设备接口**、**块设备接口**、**网络设备接口**。

![image-20250420180422448](https://bu.dusays.com/2025/04/20/6804c7d48a065.png)

**网络套接字接口**的系统调用使用应用程序创建的本地套接字连接到远程应用程序创建的套接字，通过此发送和接收数据：

![image-20250420180237910](https://bu.dusays.com/2025/04/20/6804c7d8db3e6.png)

这一段咸鱼对套接字的讲解很精彩，多看两遍（`7 分 11 秒`处）：[5.1_5_输入输出应用程序接口和驱动程序接口_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1YE411D7nH)

操作系统的 I/O 接口还涉及两种模式：**阻塞**和**非阻塞**

- **阻塞 I/O**：应用程序发出 I/O 系统调用，**进程需转换为阻塞态等待**。例如字符设备接口——从键盘读一个字符 get。
- **非阻塞 I/O**：应用程序发出 I/O 系统调用，系统调用可迅速返回，**进程无需阻塞等待**。块设备接口——往磁盘写数据 write。

### 2.设备驱动程序接口

操作系统规定好设备驱动程序的借口标准，各厂商必须按要求开发设备驱动程序：

<img src="https://bu.dusays.com/2025/04/21/680640c2df159.png" alt="image-20250421134526144" style="zoom:67%;" />

即，**设备驱动程序**是 I/O 系统的上层与设备控制器之间的通信程序。

**设备驱动程序的功能**：

- 接收上层软件发来的命令和参数，并将抽象要求转换为与设备相关的具体要求。
- 检查用户 I/O 请求的合法性，了解设备的工作状态，传递与设备操作有关的参数，设置设备的工作方式。
- 发出 I/O 命令，若设备空闲，则立即启动它，完成指定的 I/O 操作；若设备忙，则将请求者的 PCB 挂到设备队列上等待。
- 及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理。

**设备驱动程序的特点**（与普通的应用程序和系统程序相比，有以下差异）：

- 设备驱动程序将抽象的 I/O 请求转换成具体的 I/O 操作后，传送给设备控制器，并将设备控制器中记录的设备状态和 I/O 操作的完成情况及时地反馈给请求进程。
- 设备驱动程序与设备采用的 I/O 控制方式紧密相关，常用的 I/O 控制方式是中断驱动程序方式和 DMA 方式。
- 设备驱动程序与硬件密切相关，对于不同类型的设备，应配置不同的设备驱动程序。
- 由于设备驱动程序与硬件紧密相关，目前很多设备驱动程序的基本部分已固化在 ROM 中。
- 设备驱动程序应允许同时多次调用执行。

## 五、I/O 核心子系统

### 1.介绍

在 I/O 系统的分层中，设备独立性软件、设备驱动程序、中断处理程序这中间三层属于操作系统的内核部分，即 **I/O 系统**，或称 **I/O 核心子系统**。

其主要功能有：I/O 调度、设备保护、假脱机技术（SPOOLing 技术）、设备分配与回收、缓冲区管理（即缓冲与高速缓存）。

<img src="https://bu.dusays.com/2025/04/21/680640c865073.png" alt="image-20250421140810468" style="zoom:67%;" />

**I/O 调度**：用某种算法确定一个好的顺序来处理各个 I/O 请求。

**设备保护**：在 UNIX 系统中，设备被看做是一种特殊的文件，每个设备也会有对应的 FCB。当用户请求访问某个设备时，系统根据 FCB 中记录的信息来判断该用户是否有相应的访问权限。

> **注意**：假脱机技术在实际当中是在用户层实现的，但是在 408 大纲中，也把它归为 I/O 核心子系统要实现的功能之一。

### 2.假脱机技术（SPOOLing 技术）

为了缓和 CPU 的高速性与 I/O 设备的低速度性之间的矛盾，引入了**假脱机技术**，它是操作系统中采用的一项将独占设备改造成共享设备的技术。

**脱机技术**：

![image-20250421142746662](https://bu.dusays.com/2025/04/21/680640dd23d10.png)

基于脱机技术的思想，人们发明了假脱机技术，又称 SPOOLing 技术，用软件的方式模拟脱机技术。其组成如下：

![image-20250421143042104](https://bu.dusays.com/2025/04/21/680640e214ef1.png)

**输入井**模拟脱机脱机输入时的键盘，用于收容 I/O 设备输入的数据。**输出井**模拟脱机输出时的磁盘，用于收容用户程序的输出数据。一个进程的输入（或输出）数据保存为一个文件，所有进程的输入（或输出）文件链接成一个输入（或输出）队列。

**输入进程**用于模拟脱机输入时的**外围控制机**，将用户要求的数据从输入设备传送到输入缓冲区，再存放到输入井中。当CPU需要输入数据时，直接从输入井读入内存。**输出进程**用于模拟脱机输出时的**外围控制机**，将用户要求输出的数据从内存传送到输出井，待输出设备空闲时，再将输出井中的数据经输出缓冲区输出至输出设备，

**共享打印机原理分析**：

<img src="https://bu.dusays.com/2025/04/21/680642b9b9b23.png" alt="image-20250421144428193" style="zoom:67%;" />

当多个用户进程提出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事：

1. 在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中。
2. 为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上。

当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务。

SPOOLing 技术可以把一台物理设备**虚拟**成逻辑上的多台设备，可将独占式设备改造成共享设备。

### 3.设备的分配与回收

#### （1）设备分配时应考虑的因素

**①设备的固有属性**：

- **独占设备**：一个时段只能分配给一个进程（如打印机）。
- **共享设备**：可同时分配给多个进程使用（如磁带），各进程往往是宏观上同时共享使用设备，而微观上交替使用。
- **虚拟设备**：采用 SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用 SPOOLing 技术实现的共享打印机）。

**②设备的分配算法**：

- **FCFS 算法**
- **最高优先级优先算法**

**③设备分配中的安全性**：

**安全分配方式**：为进程分配一个设备后就将进程阻塞，本次 I/O 完成后才将进程唤醒（一个时间段内每个进程只能使用一个设备）。

- **优点**：破坏了 “请求和保持” 条件，不会死锁。
- **缺点**：对于一个进程来说，CPU 和 I/O 设备只能串行工作。

**不安全分配方式**：进程发出 I/O 请求后，系统为其分配 I/O 设备，进程可继续执行，之后还可以发出新的 I/O 请求。只有某个请求得不到满足时才将进程阻塞（一个进程可以同时使用多个设备）。

- **优点**：进程的计算任务和 I/O 任务可以并行处理，使进程迅速推进。
- **缺点**：有可能发生死锁（死锁避免、死锁的检测和解除）。

#### （2）静态分配与动态分配

**静态分配**：进程运行前为其分配全部所需资源，运行结束后归还资源（破坏了 “请求和保持” 条件，不会发生死锁。）。

**动态分配方式**：进程运行过程中动态申请设备资源。

#### （3）设备分配管理中的数据结构

**设备、控制器、通道之间的关系**：一个通道可控制多个设备控制器，每个设备控制器可控制多个设备。

<img src="https://bu.dusays.com/2025/04/21/680642be990e4.png" alt="image-20250421183128543" style="zoom: 67%;" />

**设备控制表（DCT）**：系统为每个设备配置一张 DCT，用于记录设备情况。

![image-20250421183640068](https://bu.dusays.com/2025/04/21/680642c1370fd.png)

> **注意**：系统会根据阻塞原因的不同，将进程 PCB 挂到不同的阻塞队列中。因此，这里需要设备队列的队首指针指向正在等待该设备的进程队列。

**控制器控制表（COCT）**：每个设备控制器都会对应一张 COCT。操作系统根据 COCT 的信息对控制器进行操作和管理。

![image-20250421184739654](https://bu.dusays.com/2025/04/21/680642c445b74.png)

**通道控制表（CHCT）**：每个通道都会对应一张 CHCT。操作系统根据 CHCT 的信息对通道进行操作和管理。

![image-20250421184954357](https://bu.dusays.com/2025/04/21/680642c74b591.png)

**系统设备表（SDT）**：记录了系统中全部设备的情况，每个设备对应一个表目。

![image-20250421185311759](https://bu.dusays.com/2025/04/21/680642c9834d9.png)

#### （4）设备分配的步骤

①根据进程请求的**物理设备名**查找 SDT（物理设备名是进程请求分配设备时提供的参数）。

②根据 SDT 找到 DCT，若**设备**忙碌则将进程 PCB 挂到**设备等待队列**中，不忙碌则将**设备**分配给进程。

③根据 DCT 找到 COCT，若**控制器**忙碌则将进程 PCB 挂到**控制器等待队列**中，不忙碌则将**控制器**分配给进程。

④根据 COCT 找到 CHCT，若**通道**忙碌则将进程 PCB 挂到**通道等待队列**中，不忙碌则将**通道**分配给进程。

**缺点**：

- 用户编程时必须使用 “物理设备名”，底层细节对用户不透明，不方便编程。
- 若换了一个物理设备，则程序无法运行。
- 若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待。

**改进方法**：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名。

#### （5）设备分配步骤的改进

①根据进程请求的**逻辑设备名**查找 SDT（用户编程时提供的逻辑设备名其实就是 “设备类型”）。

②查找 SDT，找到用户进程**指定类型的、并且空闲**的设备，将其分配给该进程。操作系统**在逻辑设备表（LUT）中新增一个表项**。

③根据 DCT 找到 COCT，若控制器忙碌则将进程 PCB 挂到控制器等待队列中，不忙碌则将控制器分配给进程。

④根据 COCT 找到 CHCT，若通道忙碌则将进程 PCB 挂到通道等待队列中，不忙碌则将通道分配给进程。

<img src="https://bu.dusays.com/2025/04/21/680642ce59135.png" alt="image-20250421191446614" style="zoom: 80%;" />

逻辑设备表（LUT）建立了逻辑设备名与物理设备名之间的映射关系。某用户进程第一次使用逻辑设备名向操作系统发出请求时，操作系统会在为其分配的同时在 LUT 中增加相应表项。

如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过 LUT 表即可知道用户进程实际要使用的是哪个物理设备，以及该设备的驱动程序入口地址。

逻辑设备表的设置问题：

- **整个系统只有一张 LUT**：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统。
- **每个用户一张 LUT**：不同用户的逻辑设备名可重复，适用于多用户操作系统。

### 4.缓冲区管理

**缓冲区**是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。

**缓冲区的作用**：

- 缓和 CPU 与 I/O 设备之间速度不匹配的矛盾
- 减少对 CPU 的中断频率，放宽对 CPU 中断相应时间的限制
- 解决数据粒度不匹配的问题（输出进程每次可以生成一块数据，但 I/O 设备每次只能输出一个字符）
- 提高 CPU 与 I/O 设备之间的并行性

使用硬件作为缓冲区的成本高、容量小，一般仅用于对速度要求非常高的场合（如存储器管理中的联想寄存器）。

一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件” 的缓冲区管理就是要组织管理好这些缓冲区，下面将要介绍均为内存组成的缓冲区。

根据系统设置缓冲区的个数，缓冲技术可以分为以下几种：

**（1）单缓冲**

若采用**单缓冲**的策略，操作系统会在主存中为其**分配一个缓冲区**（无特别说明，则默认一个缓冲区的大小就是一个块）。

![image-20250421195132074](https://bu.dusays.com/2025/04/21/680642d2ab0b3.png)

> **注意**：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。

**处理一块数据的平均用时**：

![image-20250421200710726](https://bu.dusays.com/2025/04/21/680642d6612d9.png)

![image-20250421200624467](https://bu.dusays.com/2025/04/21/680642d9938f5.png)

**总结**：平均耗时 Max（C，T）+ M

**（2）双缓冲**

若采用**双缓冲**的策略，操作系统会在主存中为其分配两个缓冲区（无特别说明，则默认一个缓冲区的大小就是一个块）。

![image-20250421201454509](https://bu.dusays.com/2025/04/21/680642dcccaea.png)

![image-20250421201345569](https://bu.dusays.com/2025/04/21/680642e172647.png)

**总结**：平均耗时 Max（T，C + M）

**使用单/双缓冲在通信时的区别**：若两台机器之间仅配置了单缓冲，则它们在任意**时刻**都只能实现**单方向**的数据传输，而绝不允许双方同时向对方发送数据。为了实现**双向数据传输**，必须在两台机器中都设置两个缓冲区，一个作发送缓冲区，另一个用作接收缓冲区。

**（3）循环缓冲**

将多个**大小相等**的缓冲区链接成一个**循环队列**。下图中，橙色表示已充满数据的缓冲区，绿色表示空缓冲区。

<img src="https://bu.dusays.com/2025/04/21/680642e468ab4.png" alt="image-20250421202842182" style="zoom: 80%;" />

**（4）缓冲池**

**缓冲池**由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：

- **空缓冲队列**
- 装满输入数据的缓冲队列（**输入队列**）
- 装满输出数据的缓冲队列（**输出队列**）

此外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：

- 用于收容输入数据的工作缓冲区（hin）
- 用于提取输入数据的工作缓冲区（sin）
- 用于收容输出数据的工作缓冲区（hout）
- 用于提取输出数据的工作缓冲区（sout）

<img src="https://bu.dusays.com/2025/04/21/680642e768740.png" alt="image-20250421203800892" style="zoom:80%;" />

缓冲池中的缓冲区有以下四种工作方式：

- **收容输入**：输入进程需要输入数据时，从空缓冲队列的队首摘下一个空缓冲区，作为收容输入工作缓冲区，然后将数据输入其中，装满后再将它挂到输入队列的队尾。
- **提取输入**：计算进程需要输入数据时，从输入队列的队首取得一个缓冲区，作为提取输入工作缓冲区，从中提取数据，用完该数据后将它挂到空缓冲队列的列尾。
- **收容输出**：计算进程需要输出数据时，从空缓冲队列的队首取得一个空缓冲区，作为收容输出工作缓冲区，当其中装满数据后，再将它挂到输出队列的队尾。
- **提取输出**：输出进程需要输出数据时，从输出队列的队首取得一个装满输出数据的缓冲区，作为提取输出工作缓冲区，当数据提取完后，再将它挂到空缓冲队列的队尾。

## 六、磁盘和固态硬盘

### 1.磁盘的结构

#### （1）磁盘、磁道、扇区的概念

**磁盘**由表面涂有磁性物质的圆形盘片组成。每个盘片被划分为一个个**磁道**，每个磁道又划分为一个个**扇区**。

因为扇区按固定圆心角划分，所以密度从最外道向里道增加，磁盘的存储能力受限于最内道的最大记录密度。

> **注意**：为了提高磁盘的存储容量，充分利用磁盘外层磁道的存储能力，现代磁盘不再将内外磁道划分为相同数据的扇区，而将盘面划分为若干**环带**，同一环带内的所有磁道具有相同的扇区数，显然，外层环带的磁道拥有较内层环带的磁道更多的扇区。

#### （2）盘面、柱面及磁盘的物理地址

<img src="https://bu.dusays.com/2025/04/22/68075437cab5e.png" alt="image-20250422141936542" style="zoom:67%;" />

可用**（柱面号，盘面号，扇区号）** 来定位任意一个磁盘块。前面文件的物理结构中提到的文件数据存放在外存的几号块，这个块号就可以转换为（柱面号，盘面号，扇区号）的地址形式。

读/写磁盘数据块的过程如下：

1. 根据柱面号移动磁臂，让磁头指向指定柱面。
2. 激活指定盘面对应的磁头。
3. 当磁盘旋转时，磁头从对应扇区上划过，从而完成对指定扇区的读/写。

#### （3）磁盘的分类

按磁头是否可以移动划分：

- 磁头可以移动的称为**活动头磁盘**。磁臂可以来回伸缩来带动磁头定位磁道。
- 磁头不可移动的称为**固定头磁盘**。这种磁盘中每个磁道都有一个磁头。

按盘片是否可以更换划分：

- 盘片可以更换的称为**可换盘磁盘**。
- 盘片不可更换的称为**固定盘磁盘**。

### 2.磁盘调度算法

#### （1）磁盘的存取时间

磁盘的存取时间：**寻道时间** + **旋转延迟时间** + **传输时间**

![image-20250422144751915](https://bu.dusays.com/2025/04/22/6807543c87a9c.png)

**旋转延迟时间**和**传输时间**都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间。

**寻道时间**在磁盘的存取时间中占大头，且与磁盘调度算法密切相关。

#### （2）先来先服务（FCFS）

**FCFS**：根据进程请求访问磁盘的先后顺序进行调度。

**优点**：公平。如果请求访问的磁道比较集中，则算法性能较好。

**缺点**：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则性能很差。

#### （3）最短寻找时间优先（SSTF）

**SSTF**：优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短（贪心算法的思想）。

**优点**：性能较好，平均寻道时间短。

**缺点**：可能产生饥饿现象。

#### （4）扫描算法（SCAN）

**SCAN**：只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内磁道的时候才能往外移动。也叫**电梯调度算法**。

**优点**：性能较好，平均寻道时间较短，不会产生饥饿现象。

**缺点**：①只有到达最边长的磁道才能改变磁头方向。②对各个位置磁道的响应频率不平均，偏向于处理接近最里或最外的磁道的访问请求。③对最近扫描过的区域不公平，在访问局部性方面性能差。

**对缺点①的改进**：

**LOOK 调度算法**：如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。

#### （5）循环扫描算法（C - SCAN）

**C - SCAN**：磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。

C - SCAN 解决了 SCAN 的缺点②。

**优点**：对各个位置磁道的响应频率平均。

**缺点**：①只有到达最边长的磁道才能改变磁头方向。此外，返回时，每次都需要返回到最边缘的磁道。②平均寻道时间更长。

**C - LOOK 调度算法**：在 C - SCAN 算法的基础上优化，如果在磁头移动方向上已经没有别的请求，就可以立即让磁头返回；磁头只需要返回到最靠近边缘的、并且需要访问的磁道上即可。

> **注意**：无特别说明下，SCAN 就是 LOOK，C - SCAN 就是 C - LOOK。

### 3.减少磁盘延迟时间的方法

磁头读取一个扇区的内容后，需要一小段时间处理才能继续读下一扇区，而盘片又是不停旋转的。因此，如果要读的两个扇区相邻排列，则读完第一个扇区后会因为后摇错过第二个扇区，必须等第二个扇区再次转回来时，才能读入。

**结论**：磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的**延迟时间**。

可以采用**交替编号**的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。

![image-20250422154639162](https://bu.dusays.com/2025/04/22/68075443b01bb.png)

> **思考**：为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）？
>
> **答**：读取地址连续的磁盘块时，可以减少磁头移动消耗的时间（减少柱面的切换频率）。

**错位命名法**：原理与交替编号类似，防止读完 0 号磁盘后，由于准备时间错过 1 号磁盘上要读取的相邻数据。

![image-20250422155141213](https://bu.dusays.com/2025/04/22/68075446cf617.png)

### 4.磁盘的管理

#### （1）磁盘初始化

**Step 1**：进行**低级格式化**（**物理格式化**），将磁盘的各个磁道划分为扇区。一个扇区通常可分为头、数据区域、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC 循环冗余校验码等，用于检验扇区中的数据是否发生错误）。

**Step 2**：将磁盘分区，每个分区由若干柱面组成。

**Step 3**：进行**高级格式化**（**逻辑格式化**），创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表）。

#### （2）引导块

计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行**初始化程序**（**自举程序**）完成的。

自举程序通常存放在 ROM 中，但为了避免改变自举代码而需要改变 ROM 硬件的问题，通常只在 **ROM** 中保留很小的**自举装入程序**，而将**完整功能的引导程序**保存在磁盘的**启动块**上，启动块位于磁盘的**固定位置**。具有启动分区的磁盘称为**启动磁盘**或**系统磁盘**。

#### （3）坏块

坏块属于硬件故障，操作系统无法修复，应将坏块标记出来，避免错误使用。

对于简单的磁盘，可以在逻辑格式化（建立文件系统时）对整个磁盘进行坏块检查，标明哪些扇区是坏扇区。比如：在 FAT 表上表明。这种方式中，**坏块对操作系统不透明**。

对于复杂的磁盘，控制器维护维护磁盘内的坏块列表。这个列表在出厂低级格式化时就已初始化，并在磁盘的使用过程中不断更新。低级格式化将一些块保留作为备用，用于替换坏块。这种方案称为**扇区备用**。且这种处理方式中，**坏块对操作系统透明**。

### 5.固态硬盘 SSD

具体内容同计算机组成原理第三章：

![image-20250422163142875](https://bu.dusays.com/2025/04/22/6807544aa8397.png)



